// собственно обмены выполняет модуль менеджера Справочники.AINSYS_ОписаниеДанных

#Область РаскраскаКода
// Заимствовано https://its.1c.ru/db/metod8dev#content:3684:hdoc:_top:%D1%80%D0%B0%D1%81%D0%BA%D1%80%D0%B0%D1%81%D0%BA%D0%B0%D0%BA%D0%BE%D0%B4%D0%B0

// Процедура раскрашивания текста
//	Патаметр - Строка - код для разукраски
//	Возвращаемое значение - Строка - HTML строка. 
Функция РаскраситьТекст(Текст) Экспорт
	Возврат СтрШаблон(
		"<!DOCTYPE html>
		|<HTML>
		|<HEAD>
		|<TITLE>Код с оформлением</TITLE>
		|</HEAD>
		|<BODY>
		|<PRE style=""color: blue;font-family: """"Consolas"""";font-size: 10pt;""><CODE class=""language-1c"">%1</CODE></PRE>
		|</BODY>
		|</HTML>",
		РаскраситьМногострочныйКод(Текст)
	);
КонецФункции

// Возвращает соответствие из открывающих тегов для раскраски кода.
Функция ОткрывающиеТеги()
	Результат = Новый Соответствие;
	Результат.Вставить("КлючевоеСлово", "<font color=red>");
	Результат.Вставить("Комментарий", "<font color=green>");
	Результат.Вставить("Строка", "<font color=black>");
	Результат.Вставить("Число", "<font color=black>");
	Результат.Вставить("Препроцессор", "<font color=brown>");
	Возврат Результат;
КонецФункции

// Возвращает соответствие ключевых слов встроенного языка.
//
// Возвращаемое значение:
//   Соответствие - Соответствие - Ключевые слова встроенного языка в нижнем регистре.
//       Ключ - Строка - Ключевое слово.
//       Значение - Булево - Истина для всех ключевых слов.
//
Функция КлючевыеСлова()
	Массив = Новый Массив;
	Массив.Добавить("if");
	Массив.Добавить("если");
	Массив.Добавить("then");
	Массив.Добавить("тогда");
	Массив.Добавить("elsif");
	Массив.Добавить("иначеесли");
	Массив.Добавить("else");
	Массив.Добавить("иначе");
	Массив.Добавить("endif");
	Массив.Добавить("конецесли");
	Массив.Добавить("do");
	Массив.Добавить("цикл");
	Массив.Добавить("for");
	Массив.Добавить("для");
	Массив.Добавить("to");
	Массив.Добавить("по");
	Массив.Добавить("each");
	Массив.Добавить("каждого");
	Массив.Добавить("in");
	Массив.Добавить("из");
	Массив.Добавить("while");
	Массив.Добавить("пока");
	Массив.Добавить("endDo");
	Массив.Добавить("конеццикла");
	Массив.Добавить("procedure");
	Массив.Добавить("процедура");
	Массив.Добавить("endprocedure");
	Массив.Добавить("конецпроцедуры");
	Массив.Добавить("function");
	Массив.Добавить("функция");
	Массив.Добавить("endfunction");
	Массив.Добавить("конецфункции");
	Массив.Добавить("var");
	Массив.Добавить("перем");
	Массив.Добавить("export");
	Массив.Добавить("экспорт");
	Массив.Добавить("goto");
	Массив.Добавить("перейти");
	Массив.Добавить("and");
	Массив.Добавить("и");
	Массив.Добавить("or");
	Массив.Добавить("или");
	Массив.Добавить("not");
	Массив.Добавить("не");
	Массив.Добавить("val");
	Массив.Добавить("знач");
	Массив.Добавить("break");
	Массив.Добавить("прервать");
	Массив.Добавить("continue");
	Массив.Добавить("продолжить");
	Массив.Добавить("return");
	Массив.Добавить("возврат");
	Массив.Добавить("try");
	Массив.Добавить("попытка");
	Массив.Добавить("except");
	Массив.Добавить("исключение");
	Массив.Добавить("endTry");
	Массив.Добавить("конецпопытки");
	Массив.Добавить("raise");
	Массив.Добавить("вызватьисключение");
	Массив.Добавить("false");
	Массив.Добавить("ложь");
	Массив.Добавить("true");
	Массив.Добавить("истина");
	Массив.Добавить("undefined");
	Массив.Добавить("неопределено");
	Массив.Добавить("null");
	Массив.Добавить("new");
	Массив.Добавить("новый");
	Массив.Добавить("execute");
	Массив.Добавить("выполнить");
	
	Соответствие = Новый Соответствие;
	Для Каждого Элемент Из Массив Цикл
		Соответствие.Вставить(Элемент, Истина);
	КонецЦикла;
	Возврат Соответствие;
КонецФункции

// Возвращает соответствие операторов встроенного языка.
//
// Возвращаемое значение:
//   Соответствие - Операторы встроенного языка.
//       * Ключ - Строка - Оператор.
//       * Значение - Булево - Истина для всех операторов.
//
Функция Операторы()
	Массив = Новый Массив;
	Массив.Добавить(")");
	Массив.Добавить("(");
	Массив.Добавить("[");
	Массив.Добавить("]");
	Массив.Добавить(".");
	Массив.Добавить(",");
	Массив.Добавить("=");
	Массив.Добавить("+");
	Массив.Добавить("-");
	Массив.Добавить("<");
	Массив.Добавить(">");
	Массив.Добавить(";");
	Массив.Добавить("?");
	Массив.Добавить("*");
	
	Соответствие = Новый Соответствие;
	Для Каждого Элемент Из Массив Цикл
		Соответствие.Вставить(Элемент, Истина);
	КонецЦикла;
	Возврат Соответствие;
КонецФункции

// Функция последовательно перебирает все строки переданного кода
// 
// Параметры:
//   Код - Код, который подлежит окраске
//
// Возвращаемое значение:
//   Буфер - Окрашенный код, заключенный в тег <pre>
//
Функция РаскраситьМногострочныйКод(Код)
	
	Буфер = "";
	
	// Последовательно перебираются все строки кода, окрашиваются
	// и записываются в буфер
	Для счт = 1 По СтрЧислоСтрок(Код) Цикл
		
		стр = СтрПолучитьСтроку(Код, счт);
		Буфер = Буфер + РаскраситьСтрокуКода(стр) + Символы.ПС;
		
	КонецЦикла;
	
	Возврат Буфер;
	
КонецФункции

// Функция получения символа из строки в заданной позиции
// 
// Параметры:
//   Строка - Строка, из которой берется символ
//   Поз    - Позиция получаемого символа в строке
//
// Возвращаемое значение:
//   Символ из запрашиваемой позиции
//
Функция ПолучитьСимвол(Строка, Поз)
	
	Возврат Сред(Строка, Поз, 1);
	
КонецФункции

// Токен проверяется на принадлежность к ключевым словам встроенного языка
//
// Параметры:
//   Токен - Строка - проверяемый токен
//
// Возвращаемое значение:
//   Булево - Истина, если токен является ключевым словом встроенного языка, Ложь - не является.
//
Функция ЭтоКлючевоеСлово(Токен)
	КлючевыеСлова = КлючевыеСлова(); // lyay
	Возврат КлючевыеСлова[НРег(Токен)] = Истина;
КонецФункции

// Проверяется символ на принадлежность к специальным символам
//
// Параметры:
//   Символ - Строка - Проверяемый символ
//
// Возвращаемое значение:
//   Булево - Истина, если Символ является специальным символом, Ложь - не является.
//
Функция ЭтоОператор(Символ)
	Операторы = Операторы(); // lyay
	Возврат Операторы[Символ] = Истина;
КонецФункции

// Процедура раскраски токена.
//
// Параметры:
//   СтрокаКода - Текущая строка кода
//   Токен      - Токен, который окрашивается
//   Поз        - Позиция начала Токена в текущей строке
//   Класс      - Класс, к которому принадлежит токен
//
Процедура РаскраситьТокен(СтрокаКода, Токен, Поз, Класс)
	ОткрывающиеТеги = ОткрывающиеТеги(); // lyay
	ДлинаТокена = СтрДлина(Токен);
	
	СтрокаКода = Лев(СтрокаКода, Поз - ДлинаТокена) + 
		ОткрывающиеТеги[Класс] + 
		Сред(СтрокаКода, Поз - ДлинаТокена + 1, ДлинаТокена) +
		"</font>" + 
		Прав(СтрокаКода, СтрДлина(СтрокаКода) - Поз);
	Поз = Поз + СтрДлина(ОткрывающиеТеги[Класс] + "</font>");
	
КонецПроцедуры

// Основная функция раскрашивания кода.
//
// Параметры:
//   СтрокаКода - Строка - Раскрашивание происходит построчно, этот параметр - текущая строка.
//
// Возвращаемое значение:
//   Строка - Раскрашенная строка кода.
//
Функция РаскраситьСтрокуКода(СтрокаКода)
	 // [ lyay
	ВСтроке = Ложь;
	КлючевыеСлова = КлючевыеСлова();
	ОткрывающиеТеги = ОткрывающиеТеги();
	//]
	Поз = 1;
	Состояние = 0;
	Токен = "";
	НачалоСтроки = 1;
	
	// Последовательно перебираются все символы строки кода
	Пока Поз <> СтрДлина(СтрокаКода) + 1 Цикл
		
		ТекущийСимвол = ПолучитьСимвол(СтрокаКода, Поз);
		Если ТекущийСимвол = "/" Тогда
			
			// Проверяется на комментарий или на символ деления
			Если Не ВСтроке Тогда 
				Если ПолучитьСимвол(СтрокаКода, Поз + 1) = "/" Тогда
					// Окрашиваем комментарий
					СтрокаКода = Лев(СтрокаКода, Поз - 1) + 
						ОткрывающиеТеги["Комментарий"] + 
						Прав(СтрокаКода, СтрДлина(СтрокаКода) - Поз + 1) +
						"</font>";
					Возврат СтрокаКода;
				Иначе
					// Это символ деления
					РаскраситьТокен(СтрокаКода, ТекущийСимвол, Поз, "КлючевоеСлово");
					Токен = "";
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли ТекущийСимвол = Символы.Таб Или ТекущийСимвол = " " Тогда
			
			// Операции при встрече символа табуляции или пробела
			Если Не ВСтроке Тогда 
				Если Не ПустаяСтрока(Токен) Тогда
					Поз = Поз - 1;
					// Пробел после после токена, значит
					// токен - ключевое слово...
					Если ЭтоКлючевоеСлово(Токен) Тогда
						РаскраситьТокен(СтрокаКода, Токен, Поз, "КлючевоеСлово");
					Иначе
						// ... или число
						Попытка
							ч = Число(Токен);
							РаскраситьТокен(СтрокаКода, Токен, Поз, "Число");
						Исключение
						КонецПопытки;
					КонецЕсли;
					Поз = Поз + 1;
					Токен = "";
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли ТекущийСимвол = """" Тогда
			
			Если ВСтроке Тогда
				// Нашли парную кавычку - окрашиваем как строку
				СтрокаКода = Лев(СтрокаКода, НачалоСтроки - 1) + 
					ОткрывающиеТеги["Строка"] + 
					Сред(СтрокаКода, НачалоСтроки, Поз - НачалоСтроки + 1) +
					"</font>" +
					Прав(СтрокаКода, СтрДлина(СтрокаКода) - Поз);
				Поз = Поз + СтрДлина(ОткрывающиеТеги["Строка"] + "</font>");
				ВСтроке = Ложь;
				Токен = "";
			Иначе
				// Первая кавычка, запоминаем позицию и взводим флаг нахождения в строке
				НачалоСтроки = Поз;
				ВСтроке = Истина;
			КонецЕсли;
			
		ИначеЕсли ТекущийСимвол = "" Тогда
			
			Прервать;
			
		ИначеЕсли ЭтоОператор(ТекущийСимвол) Тогда
			
			// Встретился один из специальных символов
			Если Не ВСтроке Тогда 
				Если Не ПустаяСтрока(Токен) Тогда
					Поз = Поз - 1;
					// Дабы избежать окраски метода объекта с совпадающим
					// именем с одним из ключевых слов, проверяем текущий символ
					// на "."
					Если ЭтоКлючевоеСлово(Токен) И ТекущийСимвол <> "." Тогда
						РаскраситьТокен(СтрокаКода, Токен, Поз, "КлючевоеСлово");
					Иначе
						// Не ключевое слово - значит число
						Попытка
							ч = Число(Токен);
							РаскраситьТокен(СтрокаКода, Токен, Поз, "Число");
						Исключение
						КонецПопытки;
					КонецЕсли;
					Поз = Поз + 1;
					Токен = "";
				КонецЕсли;
				// Один из специальных символов
				РаскраситьТокен(СтрокаКода, ТекущийСимвол, Поз, "КлючевоеСлово");
			КонецЕсли;
			
		ИначеЕсли ТекущийСимвол = "#" Или ТекущийСимвол = "&" Тогда
			
			// Встретился символ препроцессора
			Если Не ВСтроке Тогда
				Поз = СтрДлина(СтрокаКода);
				РаскраситьТокен(СтрокаКода, СтрокаКода, Поз, "Препроцессор");
			КонецЕсли;
			
		Иначе
			
			// Остальные символы
			Токен = Токен + ТекущийСимвол;
			
		КонецЕсли;
		
		Поз = Поз + 1;
	КонецЦикла;
	
	// Многострочная строка
	Если ВСтроке Тогда
		СтрокаКода = Лев(СтрокаКода, НачалоСтроки - 1) + 
			ОткрывающиеТеги["Строка"] + 
			Сред(СтрокаКода, НачалоСтроки, Поз - НачалоСтроки + 1) +
			"</font>" +
			Прав(СтрокаКода, СтрДлина(СтрокаКода) - Поз);
		Поз = Поз + СтрДлина(ОткрывающиеТеги["Строка"] + "</font>");
		Токен = "";
	КонецЕсли;
	
	// Анализируем последний токен строки кода
	Если Не ПустаяСтрока(Токен) Тогда
		Если ЭтоКлючевоеСлово(Токен) Тогда
			Поз = Поз - 1;
			РаскраситьТокен(СтрокаКода, Токен, Поз, "КлючевоеСлово");
			Поз = Поз + 1;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтрокаКода;
	
КонецФункции

#КонецОбласти

#Область РаботаСДеревомЗначений

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ДЕРЕВОМ ЗНАЧЕНИЙ
// https://infostart.ru/1c/articles/73969/

// Функция формирует значение нового ключа строки табличной части.
//
// Параметры:
//		Дерево - ДеревоЗначений
//		СписокКлючей - СписокЗначений - Ключи строк
//
Функция ПолучитьНовыйКлючСтрокиДерева(Дерево, СписокКлючей = Неопределено) Экспорт

    Если СписокКлючей = Неопределено Тогда
        СписокКлючей = Новый СписокЗначений;
        СписокКлючей.Добавить(0);
    КонецЕсли;
    Для Каждого СтрокаДерева Из Дерево.Строки Цикл
        СписокКлючей.Добавить(СтрокаДерева.КлючСтроки);
        ПолучитьНовыйКлючСтрокиДерева(СтрокаДерева, СписокКлючей);
        СписокКлючей.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
        МаксКлюч = СписокКлючей[0].Значение + 1;
    КонецЦикла;
    Возврат МаксКлюч;

КонецФункции // ПолучитьНовыйКлючСтрокиДерева()

// Процедура обновляет ключи связи в дереве значений
//
Процедура ОбновитьКлючиСвязиВДеревеЗначений(Дерево) Экспорт

    Для Каждого СтрокаДерева Из Дерево.Строки Цикл
        Попытка
            СтрокаДерева.КлючСвязи = СтрокаДерева.Родитель.КлючСтроки;
        Исключение
            СтрокаДерева.КлючСвязи = 0;
        КонецПопытки;
        ОбновитьКлючиСвязиВДеревеЗначений(СтрокаДерева);
    КонецЦикла;

КонецПроцедуры // ОбновитьКлючиСвязиВДеревеЗначений()

// Процедура обновляет ключи связи в дереве значений
//
Процедура ОбновитьКлючиСтрокВДеревеЗначений(Дерево, КлючСтроки = 1) Экспорт

    Для Каждого СтрокаДерева Из Дерево.Строки Цикл
        СтрокаДерева.КлючСтроки = КлючСтроки;
        КлючСтроки = КлючСтроки + 1;
        ОбновитьКлючиСтрокВДеревеЗначений(СтрокаДерева, КлючСтроки);
    КонецЦикла;

КонецПроцедуры // ОбновитьКлючиСтрокВДеревеЗначений()

// Процедура выгружает данные из дерева значений в таблицу значений
// данные выгружаются только в таблицу со сходным набором реквизитов
// 
//	Возвращаемое значение ТаблицаЗначений
Функция ВыгрузитьДеревоЗначенийВТаблицуЗначений(Дерево, Таблица = Неопределено) Экспорт

    Если Таблица = Неопределено Тогда
        Таблица = Новый ТаблицаЗначений;
        Для Каждого Колонка Из Дерево.Колонки Цикл
            Таблица.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
        КонецЦикла;
    КонецЕсли;
    Для Каждого СтрокаДерева Из Дерево.Строки Цикл
        ЗаполнитьЗначенияСвойств(Таблица.Добавить(), СтрокаДерева);
        ВыгрузитьДеревоЗначенийВТаблицуЗначений(СтрокаДерева, Таблица);
    КонецЦикла;
    Возврат Таблица;

КонецФункции //ВыгрузитьДеревоЗначенийВТаблицуЗначений()

// Процедура выгружает данные из таблицы значений в дерево значений
// данные выгружаются только в таблицу со сходным набором реквизитов
//
// Параметры:
//	Таблица - ТаблицаЗначений - для обработки
//	КлючСтроки - Строка - имя колонки ТаблицыЗначений - уникальный идентификатор
//	КлючСвязи - Строка - имя колонки ТаблицыЗначений - указатель привязки к строке Дерева,
//		своего рода указатель на "Родителя"
// Возвращаемое значение - ДеревоЗначений
Функция ВыгрузитьТаблицуЗначенийВДеревоЗначений(Таблица, КлючСтроки = "КлючСтроки", КлючСвязи = "КлючСвязи") Экспорт

    Дерево = Новый ДеревоЗначений;
    Для Каждого Колонка Из Таблица.Колонки Цикл
        Дерево.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
    КонецЦикла;
    Для Каждого СтрокаТаблицы Из Таблица Цикл
        СтрокаГруппировки = Дерево.Строки.Найти(СтрокаТаблицы[КлючСвязи], КлючСтроки,Истина);
        Если СтрокаГруппировки = Неопределено Тогда
            ЗаполнитьЗначенияСвойств(Дерево.Строки.Добавить(), СтрокаТаблицы);
        Иначе
            ЗаполнитьЗначенияСвойств(СтрокаГруппировки.Строки.Добавить(), СтрокаТаблицы);
        КонецЕсли;
    КонецЦикла;
    Возврат Дерево;

КонецФункции //ВыгрузитьТаблицуЗначенийВДеревоЗначений()

// Процедура устанавливает значение во всем дереве значений
//
Процедура УстановитьЗначениеКолонкиДерева(Дерево, Колонка, Значение) Экспорт

    Для каждого СтрокаДерева Из Дерево.Строки Цикл
        СтрокаДерева[Колонка] = Значение;
        УстановитьЗначениеКолонкиДерева(СтрокаДерева, Колонка, Значение);
    КонецЦикла;

КонецПроцедуры //УстановитьЗначениеКолонкиДерева()

// Процедура копирует подчиненные строки дерева значений
//
Процедура СкопироватьПодчиненныеСтроки(СтрокаПриемник, СтрокаИсточник)

    Для каждого Строка Из СтрокаИсточник.Строки Цикл
        НоваяСтрока = СтрокаПриемник.Строки.Добавить();
        НоваяСтрока.КлючСвязи = СтрокаПриемник.КлючСтроки;
        ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
        СкопироватьПодчиненныеСтроки(НоваяСтрока, Строка);
    КонецЦикла;

КонецПроцедуры // СкопироватьПодчиненныеСтроки()

// Процедура переносит выделенные строки дерева значений в указанную ветку
//
Процедура ПеренестиСтрокиДереваЗначений(СтрокаПриемник, ВыделенныеСтроки) Экспорт

    Если НЕ СтрокаПриемник = Неопределено Тогда
        МассивСтрок = Новый Массив;
        Для Каждого СтрокаПереноса Из ВыделенныеСтроки Цикл
            МассивСтрок.Добавить(СтрокаПереноса);
            НоваяСтрока = СтрокаПриемник.Строки.Добавить();
            СкопироватьПодчиненныеСтроки(НоваяСтрока, СтрокаПереноса);
            ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаПереноса);
            НоваяСтрока.КлючСвязи = СтрокаПриемник.КлючСтроки;
        КонецЦикла;
        Для Каждого СтрокаДерева Из МассивСтрок Цикл
            Если СтрокаДерева.Родитель = Неопределено Тогда
                СтрокаДерева.Строки.Удалить(СтрокаДерева);
            Иначе
                СтрокаДерева.Родитель.Строки.Удалить(СтрокаДерева);
            КонецЕсли;
        КонецЦикла;
    КонецЕсли;

КонецПроцедуры //ПеренестиСтрокиДереваЗначений()

Функция ПодготовитьЗначениеДляJSON(Свойство, Значение, ДополнительныеПараметры, Отказ) Экспорт
	Если Значение = Null Тогда
		рез = "";
	ИначеЕсли ТипЗнч(Значение) = Тип("Строка") ИЛИ ТипЗнч(Значение) = Тип("Число") ИЛИ ТипЗнч(Значение) = Тип("Дата") Тогда
		рез = Значение;
	ИначеЕсли Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		рез = Новый Структура("id, Представление", xmlСтрока(Значение), Строка(Значение));
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		рез = Новый Структура("id, Представление", xmlСтрока(Значение), Строка(Значение));
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		рез = Новый Структура("id, Представление", xmlСтрока(Значение), Строка(Значение));
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		рез = Новый Структура("id, Представление", xmlСтрока(Значение), Строка(Значение));
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		рез = Новый Структура("id, Представление", xmlСтрока(Значение), Строка(Значение));
	Иначе
		рез = Строка(Значение);
	КонецЕсли;
	
	Возврат рез;
КонецФункции

Функция ДеревоВМассив(Дерево, Колонки, стркВышестоящиеЗначения = Неопределено, Уровень = 0) Экспорт
	МассивРезультат = Новый Массив;
	
	Для Каждого строкаДерева из Дерево.Строки Цикл
	
		Если Уровень = 0 Тогда
			стркВышестоящиеЗначения = Новый Структура;
		КонецЕсли;
		
		стрк = Новый Структура;
		Для Каждого Колонка из Колонки Цикл
			Если НЕ ЗначениеЗаполнено(строкаДерева[Колонка.Имя]) Тогда
				Продолжить;
			КонецЕсли;
			стрк.Вставить(Колонка.Имя, строкаДерева[Колонка.Имя]);
		КонецЦикла;
		
		Если строкаДерева.Строки.Количество() > 0 Тогда
			ВложеныеДанные = ДеревоВМассив(строкаДерева, Колонки, стркВышестоящиеЗначения, Уровень + 1);
			стрк.Вставить("Строки", ВложеныеДанные);
		КонецЕсли;
		МассивРезультат.Добавить(стрк);
	КонецЦикла;
	
	Возврат МассивРезультат;
КонецФункции

Функция ДеревоОтчетаВМассив(ВладелецСтрок, стркСтруктураОтчета, ИмяГруппировки = "") Экспорт
	МассивРезультат = Новый Массив;
	
	Если ИмяГруппировки = "" Тогда
		ИмяГруппировки = стркСтруктураОтчета.Имя;
	КонецЕсли;
	
	Для Каждого строкаДерева из ВладелецСтрок.Строки Цикл
		Если строкаДерева.AINSYS_ИмяГруппировки <> ИмяГруппировки Тогда
			// сюда мы попадаем когда на одном уровне отчёта есть несколько группировок
			Продолжить
		КонецЕсли;
		
		стрк = Новый Структура(стркСтруктураОтчета.ПоляГруппировки);
		ЗаполнитьЗначенияСвойств(стрк, строкаДерева);
		
		Если строкаДерева.Строки.Количество() > 0 Тогда
			// какие подчинённые вложенности у нас есть
			стркИмен = Новый Структура;
			Для Каждого стрПодчиненная из строкаДерева.Строки Цикл
				стркИмен.Вставить(стрПодчиненная.AINSYS_ИмяГруппировки, стрПодчиненная.AINSYS_ИмяГруппировки);
			КонецЦикла;
			
			// придётся пробежаться по выборке столько раз сколько группировок есть на этом уровне
			Для Каждого ЗнКлюч из стркИмен Цикл
				ВложеннаяСтруктура = Неопределено;
				Если стркСтруктураОтчета.Свойство(ЗнКлюч.Ключ, ВложеннаяСтруктура) Тогда
					ВложеныеДанные = ДеревоОтчетаВМассив(строкаДерева, ВложеннаяСтруктура, ЗнКлюч.Ключ);
					стрк.Вставить(ЗнКлюч.Ключ, ВложеныеДанные);
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
		МассивРезультат.Добавить(стрк);
	КонецЦикла;
	
	Возврат МассивРезультат;
КонецФункции

Функция ЗначениеВjson(Значение) Экспорт
	запись = Новый ЗаписьJSON;
	запись.УстановитьСтроку();
	ЗаписатьJSON(запись, Значение,, "ПодготовитьЗначениеДляJSON", AINSYS_сервер);
	Возврат запись.Закрыть();
КонецФункции

Функция ЗначениеИзJson(вхСтрока) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(вхСтрока);
	Попытка
		объектРезультат = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
	Исключение
		объектРезультат = Неопределено;
	КонецПопытки;
	
	Возврат объектРезультат;
КонецФункции

#КонецОбласти

#Область ОбщегоНазначения

Функция ОписаниеДоступаКМетодам1С(входящийЗапрос) Экспорт
	Описание = "Доступ к сущностям по запросу " + входящийЗапрос.БазовыйURL + "/data/ИДЕНТИФИКАТОР/ФОРМАТ/КОЛИЧЕСТВО/СМЕЩЕНИЕ?ПараметрыЗапроса, где
	|	ИДЕНТИФИКАТОР - идентификатор описания сущности такого вида b22e7695-82bb-11ec-822b-005056af18e8
	|	ФОРМАТ - строка json или html
	|	КОЛИЧЕСТВО - число объектов, которое нужно вернуть
	|	СМЕЩЕНИЕ - с какого объекта следует начать отсчёт количества.
	|
	|	ПараметрыЗапроса:
	|	k - ключ плана синхронизации. Обязательный. Он задётся в справочнике AINSYS_ПланыСинхронизации. В данном случае " +
	входящийЗапрос.ПараметрыЗапроса.Получить("k") + "
	|	n - признак того, что нужно вернуть только изменённые. Если ключ пуст или отсутствует, то вернёт все объекты." +
	"С отданых объектов снимается пометка изменения. То есть получить изменённые объекты можно только раз." +
	"Чтобы второй раз получить изменённые объекты их нужно пометить как изменённые в 1С
	|
	|Инициировать отправку данных в кор. систему можно GET Запросом по ссылке: " + входящийЗапрос.БазовыйURL + "/data/?k=" + входящийЗапрос.ПараметрыЗапроса.Получить("k");
	Возврат Описание;
КонецФункции

// Параметры:
//		ИД - Строка - строковое представления уникального идентификатора
//		Тип - Строка - наименование вида справочника, документа или плана обмена. Благо их наименования не пересекаются.
// Возвращаемое значение:
//		Cсылка на найденный справочник или документ или Неопределено, если объекта нет.
Функция ПолучитьСсылкуПоИД(ИД, Тип = Неопределено) Экспорт
	Если ИД = "" и Тип <> Неопределено Тогда
		// Тип известен, элемент явно пустой, значит нужно вернуть пустую ссылку
		спр = Метаданные.Справочники.Найти(Тип);
		Если спр <> Неопределено Тогда
			Возврат Справочники[Тип].ПустаяСсылка();
		КонецЕсли;
		
		док = Метаданные.Документы.Найти(Тип);
		Если док <> Неопределено Тогда
			Возврат Документы[Тип].ПустаяСсылка();
		КонецЕсли;
		
		планОбмена = Метаданные.ПланыОбмена.Найти(Тип);
		Если планОбмена <> Неопределено Тогда
			Возврат ПланыОбмена[Тип].ПустаяСсылка();
		КонецЕсли;
		
		Возврат Неопределено
	ИначеЕсли Не ЗначениеЗаполнено(ИД) Тогда
		Возврат Неопределено
	КонецЕсли;
	
	Попытка
		УИД = Новый УникальныйИдентификатор(ИД);
	Исключение
		Возврат Неопределено
	КонецПопытки;
	
	// Если тип известен, то ищем только в одной таблице
	Если Тип <> Неопределено Тогда
		спр = Метаданные.Справочники.Найти(Тип);
		Если спр <> Неопределено Тогда
			Ссылка = Справочники[Тип].ПолучитьСсылку(УИД);
			Если Не Ссылка.Пустая() и НЕ ПустаяСтрока(Ссылка.ВерсияДанных) Тогда
				Возврат Ссылка
			КонецЕсли;
			Возврат Неопределено
		КонецЕсли;
		
		док = Метаданные.Документы.Найти(Тип);
		Если док <> Неопределено Тогда
			Ссылка = Документы[Тип].ПолучитьСсылку(УИД);
			Если Не Ссылка.Пустая() и НЕ ПустаяСтрока(Ссылка.ВерсияДанных) Тогда
				Возврат Ссылка
			КонецЕсли;
			Возврат Неопределено
		КонецЕсли;
		
		мд = Метаданные.ПланыОбмена.Найти(Тип);
		Если мд <> Неопределено Тогда
			Ссылка = ПланыОбмена[Тип].ПолучитьСсылку(УИД);
			Если Не Ссылка.Пустая() и НЕ ПустаяСтрока(Ссылка.ВерсияДанных) Тогда
				Возврат Ссылка
			КонецЕсли;
		КонецЕсли;
		Возврат Неопределено
	КонецЕсли;
	
	// Если тип неизвестен, то перебираем все справочники и документы.
	// Это долго. Поэтому тип очень хочется получить.
	Для Каждого спр из Метаданные.Справочники Цикл
		Ссылка = Справочники[спр.Имя].ПолучитьСсылку(УИД);
		Если НЕ ПустаяСтрока(Ссылка.ВерсияДанных) Тогда
			Возврат Ссылка
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого док из Метаданные.Документы Цикл
		Ссылка = Документы[док.Имя].ПолучитьСсылку(УИД);
		Если НЕ ПустаяСтрока(Ссылка.ВерсияДанных) Тогда
			Возврат Ссылка
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого мд из Метаданные.ПланыОбмена Цикл
		Ссылка = ПланыОбмена[мд.Имя].ПолучитьСсылку(УИД);
		Если НЕ ПустаяСтрока(Ссылка.ВерсияДанных) Тогда
			Возврат Ссылка
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено
КонецФункции

// Если эту функцию вызывать из модуля http сервиса, то всё работает.
// если же её вызывать из других модулей, то при подключении расширения нужно снять галку "Безопасный режим"
// Пункт меню Конфигурация/Расширения конфигурации
// Возвращаемое значение - Строка - html, полученный из тд
Функция ТабличныйДокументВhtml(тд) Экспорт
	
	ВремФайл = ПолучитьИмяВременногоФайла("html");
	тд.Записать(ВремФайл, ТипФайлаТабличногоДокумента.HTML5);
	Текст = Новый ТекстовыйДокумент;
	Текст.ИспользуемоеИмяФайла = ВремФайл;
	Текст.Прочитать(ВремФайл, КодировкаТекста.UTF8);
	стрРезультат = Текст.ПолучитьТекст();
	Текст = Неопределено;
	УдалитьФайлы(ВремФайл);
	
	Возврат стрРезультат;
КонецФункции

// Приводит Значение к типу AINSYS_ТипыДанных. Если преобразовать не удалось, то возвращает Неопределено
// Значения ПеречисленияСсылка.AINSYS_ТипыДанных.Массив и ПеречисленияСсылка.AINSYS_ТипыДанных.Объект не обрабатываются
// Параметры:
//		выбЗначение - выбранное значение. Строка или Структура с полями id и Представление
//		ВыбТип - ПеречисленияСсылка.AINSYS_ТипыДанных - описывает какой результат надо получить.
Функция ПровестиЗначениеКТипу(выбЗначение, ВыбТип) Экспорт
	резЗначение = Неопределено;
	Если ВыбТип = Перечисления.AINSYS_ТипыДанных.Булево Тогда
		резЗначение = ЗначениеЗаполнено(выбЗначение);
	ИначеЕсли ВыбТип = Перечисления.AINSYS_ТипыДанных.Строка Тогда
		резЗначение = Строка(выбЗначение);
	ИначеЕсли ВыбТип = Перечисления.AINSYS_ТипыДанных.Число Тогда
		резЗначение = AINSYS_сервер.СтрокаВЧисло(выбЗначение);
	ИначеЕсли ВыбТип = Перечисления.AINSYS_ТипыДанных.Дата Тогда
		резЗначение = AINSYS_сервер.СтрокаВДату(выбЗначение);
	ИначеЕсли ВыбТип = Перечисления.AINSYS_ТипыДанных.Ссылка И ТипЗнч(выбЗначение) = Тип("Структура") Тогда
		ид = Неопределено;
		выбЗначение.Свойство("id", ид);
		резЗначение = AINSYS_сервер.ПолучитьСсылкуПоИД(ид);
	КонецЕсли;
	
	Возврат резЗначение;
КонецФункции

#Область ИзТиповой

// Вставляет параметры в строку, учитывая, что в параметрах могут использоваться подстановочные слова %1, %2 и т.д.
Функция ПодставитьПараметрыСПроцентом(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено)
	
	Результат = "";
	Позиция = СтрНайти(СтрокаПодстановки, "%");
	Пока Позиция > 0 Цикл 
		Результат = Результат + Лев(СтрокаПодстановки, Позиция - 1);
		СимволПослеПроцента = Сред(СтрокаПодстановки, Позиция + 1, 1);
		ПодставляемыйПараметр = Неопределено;
		Если СимволПослеПроцента = "1" Тогда
			ПодставляемыйПараметр = Параметр1;
		ИначеЕсли СимволПослеПроцента = "2" Тогда
			ПодставляемыйПараметр = Параметр2;
		ИначеЕсли СимволПослеПроцента = "3" Тогда
			ПодставляемыйПараметр = Параметр3;
		ИначеЕсли СимволПослеПроцента = "4" Тогда
			ПодставляемыйПараметр = Параметр4;
		ИначеЕсли СимволПослеПроцента = "5" Тогда
			ПодставляемыйПараметр = Параметр5;
		ИначеЕсли СимволПослеПроцента = "6" Тогда
			ПодставляемыйПараметр = Параметр6;
		ИначеЕсли СимволПослеПроцента = "7" Тогда
			ПодставляемыйПараметр = Параметр7
		ИначеЕсли СимволПослеПроцента = "8" Тогда
			ПодставляемыйПараметр = Параметр8;
		ИначеЕсли СимволПослеПроцента = "9" Тогда
			ПодставляемыйПараметр = Параметр9;
		КонецЕсли;
		Если ПодставляемыйПараметр = Неопределено Тогда
			Результат = Результат + "%";
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 1);
		Иначе
			Результат = Результат + ПодставляемыйПараметр;
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 2);
		КонецЕсли;
		Позиция = СтрНайти(СтрокаПодстановки, "%");
	КонецЦикла;
	Результат = Результат + СтрокаПодстановки;
	
	Возврат Результат;
КонецФункции

// Подставляет параметры в строку. Максимально возможное число параметров - 9.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров начинается с единицы.
//
// Параметры:
//  ШаблонСтроки  - Строка - шаблон строки с параметрами (вхождениями вида "%<номер параметра>", 
//                           например, "%1 пошел в %2");
//  Параметр<n>   - Строка - значение подставляемого параметра.
//
// Возвращаемое значение:
//  Строка   - текстовая строка с подставленными параметрами.
//
// Пример:
//  ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), "Вася", "Зоопарк") = "Вася пошел
//  в Зоопарк".
//
Функция ПодставитьПараметрыВСтроку(Знач ШаблонСтроки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено) Экспорт
	
	ЕстьПараметрыСПроцентом = СтрНайти(Параметр1, "%")
		Или СтрНайти(Параметр2, "%")
		Или СтрНайти(Параметр3, "%")
		Или СтрНайти(Параметр4, "%")
		Или СтрНайти(Параметр5, "%")
		Или СтрНайти(Параметр6, "%")
		Или СтрНайти(Параметр7, "%")
		Или СтрНайти(Параметр8, "%")
		Или СтрНайти(Параметр9, "%");
		
	Если ЕстьПараметрыСПроцентом Тогда
		Возврат ПодставитьПараметрыСПроцентом(ШаблонСтроки, Параметр1,
			Параметр2, Параметр3, Параметр4, Параметр5, Параметр6, Параметр7, Параметр8, Параметр9);
	КонецЕсли;
	
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%1", Параметр1);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%2", Параметр2);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%3", Параметр3);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%4", Параметр4);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%5", Параметр5);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%6", Параметр6);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%7", Параметр7);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%8", Параметр8);
	ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%9", Параметр9);
	Возврат ШаблонСтроки;
	
КонецФункции

// Используется в НайтиОшибкуДоступностиРеквизитовОбъекта.
// Выполняет проверку доступности поля проверяемого выражения в источнике оператора схемы запроса.
//
Функция ПолеИсточникаСхемыЗапросаДоступно(ИсточникОператора, ПроверяемоеВыражение)
	
	ЧастиИмениПоля = СтрРазделить(ПроверяемоеВыражение, ".");
	ДоступныеПоля = ИсточникОператора.Источник.ДоступныеПоля;
	
	ТекущаяЧастьИмениПоля = 0;
	Пока ТекущаяЧастьИмениПоля < ЧастиИмениПоля.Количество() Цикл 
		
		ТекущееПоле = ДоступныеПоля.Найти(ЧастиИмениПоля.Получить(ТекущаяЧастьИмениПоля)); 
		
		Если ТекущееПоле = Неопределено Тогда 
			Возврат Ложь;
		КонецЕсли;
		
		// Инкрементация следующей части имени поля и соответствующего списка доступности полей.
		ТекущаяЧастьИмениПоля = ТекущаяЧастьИмениПоля + 1;
		ДоступныеПоля = ТекущееПоле.Поля;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Выполняет поиск проверяемых выражений среди реквизитов объекта метаданных.
// 
// Параметры:
//  ПолноеИмяОбъектаМетаданных - Строка - полное имя проверяемого объекта.
//  ПроверяемыеВыражения       - Массив - имена полей или проверяемые выражения объекта метаданных.
// 
// Возвращаемое значение:
//  Структура - Результат проверки.
//  * Ошибка         - Булево - Найдена ошибка.
//  * ОписаниеОшибки - Строка - Описание найденных ошибок.
//
// Пример:
//  
// Реквизиты = Новый Массив;
// Реквизиты.Добавить("Номер");
// Реквизиты.Добавить("Валюта.НаименованиеПолное");
//
// Результат = ОбщегоНазначения.НайтиОшибкуДоступностиРеквизитовОбъекта("Документ._ДемоЗаказПокупателя", Реквизиты);
//
// Если Результат.Ошибка Тогда
//     ВызватьИсключение Результат.ОписаниеОшибки;
// КонецЕсли;
//
Функция НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, ПроверяемыеВыражения)
	
	МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
	
	Если МетаданныеОбъекта = Неопределено Тогда 
		Возврат Новый Структура("Ошибка, ОписаниеОшибки", Истина, 
			ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка получения метаданных ""%1""'"), ПолноеИмяОбъектаМетаданных));
	КонецЕсли;

	// Разрешение вызова из безопасного режима внешней обработки или расширения.
	// Информация о доступности полей источника схемы при проверке метаданных не является секретной.
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Схема = Новый СхемаЗапроса;
	Пакет = Схема.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	Оператор = Пакет.Операторы.Получить(0);
	
	Источник = Оператор.Источники.Добавить(ПолноеИмяОбъектаМетаданных, "Таблица");
	ТекстОшибки = "";
	
	Для Каждого ТекущееВыражение Из ПроверяемыеВыражения Цикл
		
		Если Не ПолеИсточникаСхемыЗапросаДоступно(Источник, ТекущееВыражение) Тогда 
			ТекстОшибки = ТекстОшибки + Символы.ПС + ПодставитьПараметрыВСтроку(
				НСтр("ru = '- Поле объекта ""%1"" не найдено'"), ТекущееВыражение);
		КонецЕсли;
		
	КонецЦикла;
		
	Возврат Новый Структура("Ошибка, ОписаниеОшибки", Не ПустаяСтрока(ТекстОшибки), ТекстОшибки);
	
КонецФункции

// Структура, содержащая значения реквизитов, прочитанные из информационной базы по ссылке на объект.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//                       требований к свойствам структуры.
//                       Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//                       псевдоним поля для возвращаемой структуры с результатом, а в качестве
//                       значения (опционально) фактическое имя поля в таблице.
//                       Если ключ задан, а значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//                       к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя, и в случае,
//                                    - если есть ограничение на уровне записей, то все реквизиты вернутся 
//                                      со значением Неопределено;
//                                    - если нет прав для работы с таблицей, то возникнет исключение.
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу 
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//            - если в параметр Реквизиты передана пустая строка, то возвращается пустая структура.
//            - если в параметр Ссылка передана пустая ссылка, то возвращается структура, 
//              соответствующая именам реквизитов со значениями Неопределено.
//            - если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//              то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты, ВыбратьРазрешенные = Ложь) Экспорт
	
	Попытка
		ПолноеИмяОбъектаМетаданных = Ссылка.Метаданные().ПолноеИмя(); 
	Исключение
		ВызватьИсключение НСтр("ru = 'Неверный первый параметр Ссылка: 
		                             |- Значение должно быть ссылкой или именем предопределенного элемента'");	
	КонецПопытки;
	
	// Разбор реквизитов, если второй параметр Строка.
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, " ", "");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, ",");
	КонецЕсли;
	
	// Приведение реквизитов к единому формату.
	СтруктураПолей = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктураПолей = Реквизиты;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		Для Каждого Реквизит Из Реквизиты Цикл
			
			Попытка
				ПсевдонимПоля = СтрЗаменить(Реквизит, ".", "");
				СтруктураПолей.Вставить(ПсевдонимПоля, Реквизит);
			Исключение 
				// Если псевдоним не является ключом.
				
				// Поиск ошибки доступности полей.
				Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
				Если Результат.Ошибка Тогда 
					ВызватьИсключение ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Неверный второй параметр Реквизиты: %1'"), Результат.ОписаниеОшибки);
				КонецЕсли;
				
				// Не удалось распознать ошибку, проброс первичной ошибки.
				ВызватьИсключение;
			
			КонецПопытки;
		КонецЦикла;
	Иначе
		ВызватьИсключение ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"), Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	// Подготовка результата (после выполнения запроса переопределится).
	Результат = Новый Структура;
	
	// Формирование текста запроса к выбираемым полям.
	ТекстЗапросаПолей = "";
	Для каждого КлючИЗначение Из СтруктураПолей Цикл
		
		ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
		ПсевдонимПоля = КлючИЗначение.Ключ;
		
		ТекстЗапросаПолей = 
			ТекстЗапросаПолей + ?(ПустаяСтрока(ТекстЗапросаПолей), "", ",") + "
			|	" + ИмяПоля + " КАК " + ПсевдонимПоля;
		
		
		// Предварительное добавление поля по псевдониму в возвращаемый результат.
		Результат.Вставить(ПсевдонимПоля);
		
	КонецЦикла;
	
	// Если предопределенного нет в ИБ.
	// - приведение результата к отсутствию объекта в ИБ или передаче пустой ссылки.
	Если Ссылка = Неопределено Тогда 
		Возврат Результат;
	КонецЕсли;
	
	ТекстЗапроса = 
		"ВЫБРАТЬ " + ?(ВыбратьРазрешенные, "РАЗРЕШЕННЫЕ", "") + "
		|" + ТекстЗапросаПолей + "
		|ИЗ
		|	" + ПолноеИмяОбъектаМетаданных + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка
		|";
	
	// Выполнение запроса.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Если реквизиты были переданы строкой, то они уже конвертированы в массив.
		// Если реквизиты - массив, оставляем без изменений.
		// Если реквизиты - структура - конвертируем в массив.
		// В остальных случаях уже было бы выброшено исключение.
		Если Тип("Структура") = ТипЗнч(Реквизиты) Тогда
			Реквизиты = Новый Массив;
			Для каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Реквизиты.Добавить(ИмяПоля);
			КонецЦикла;
		КонецЕсли;
		
		// Поиск ошибки доступности полей.
		Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
		Если Результат.Ошибка Тогда 
			ВызватьИсключение ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный второй параметр Реквизиты: %1'"), Результат.ОписаниеОшибки);
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	// Заполнение реквизитов.
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Значение реквизита, прочитанного из информационной базы по ссылке на объект.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  ИмяРеквизита       - Строка - имя получаемого реквизита.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя, и в случае,
//                                    - если есть ограничение на уровне записей, то возвращается Неопределено;
//                                    - если нет прав для работы с таблицей, то возникнет исключение.
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Произвольный - зависит от типа значения прочитанного реквизита.
//               - если в параметр Ссылка передана пустая ссылка, то возвращается Неопределено.
//               - если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//                 то возвращается Неопределено.
//
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные = Ложь) Экспорт
	
	Если ПустаяСтрока(ИмяРеквизита) Тогда 
		ВызватьИсключение НСтр("ru = 'Неверный второй параметр ИмяРеквизита: 
		                             |- Имя реквизита должно быть заполнено'");
	КонецЕсли;
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции 

// Преобразует исходную строку в число без вызова исключений.
//
// Параметры:
//   Значение - Строка - Строка, которую необходимо привести к числу.
//                       Например, "10", "+10", "010", вернет 10;
//                                 "(10)", "-10",вернет -10;
//                                 "10,2", "10.2",вернет 10.2;
//                                 "000", " ", "",вернет 0;
//                                 "10текст", вернет Неопределено.
//
// Возвращаемое значение:
//   Число, Неопределено - Полученное число, либо Неопределено, если строка не является числом.
//
Функция СтрокаВЧисло(Знач Значение) Экспорт
	
	Значение  = СтрЗаменить(Значение, " ", "");
	Если СтрНачинаетсяС(Значение, "(") Тогда
		Значение = СтрЗаменить(Значение, "(", "-");
		Значение = СтрЗаменить(Значение, ")", "");
	КонецЕсли;
	
	СтрокаБезНулей = СтрЗаменить(Значение, "0", "");
	Если ПустаяСтрока(СтрокаБезНулей) Или СтрокаБезНулей = "-" Тогда
		Возврат 0;
	КонецЕсли;
	
	ТипЧисло  = Новый ОписаниеТипов("Число");
	Результат = ТипЧисло.ПривестиЗначение(Значение);
	
	Возврат ?(Результат <> 0 И Не ПустаяСтрока(СтрокаБезНулей), Результат, Неопределено);
	
КонецФункции

// Преобразует исходную строку в дату.
//
// Параметры:
//  Значение - Строка - Строка, которую необходимо привести к дате.
//                      Формат даты должен быть в виде "ДД.ММ.ГГГГ" или "ДД/ММ/ГГ" или "ДД-ММ-ГГ",
//                      Например, "23.02.1980" или "23/02/80".
// 
// Возвращаемое значение:
//  Дата - полученная дата.
//
Функция СтрокаВДату(Знач Значение) Экспорт
	
	Значение = СтрЗаменить(Значение, " ", "");
	Значение = СокрЛП(СтрЗаменить(Значение, ".", ""));
	Значение = СокрЛП(СтрЗаменить(Значение, "/", ""));
	Значение = СокрЛП(СтрЗаменить(Значение, "-", ""));
	Значение = Сред(Значение, 5) + Сред(Значение, 3, 2) + Лев(Значение, 2);
	Если СтрДлина(Значение) = 6 Тогда
		Год = СтрокаВЧисло(Лев(Значение, 2));
		Если Год = Неопределено Тогда 
			Возврат Дата('0001.01.01');
		КонецЕсли;
		Значение = ?(Год > 29, "19", "20") + Значение;
	КонецЕсли;
	
	ОписаниеТипа = Новый ОписаниеТипов("Дата");
	Результат    = ОписаниеТипа.ПривестиЗначение(Значение);
	
	Возврат Результат;
	
КонецФункции 

#КонецОбласти

#КонецОбласти

#Область Отправка

Процедура ОтправитьДанныеПланаСинхронизации(спрПланСинхронизации) Экспорт
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	AINSYS_ОписаниеДанных.Ссылка КАК Ссылка
	               |ИЗ
	               |	Справочник.AINSYS_ОписаниеДанных КАК AINSYS_ОписаниеДанных
	               |ГДЕ
	               |	НЕ AINSYS_ОписаниеДанных.ПометкаУдаления
	               |	И НЕ AINSYS_ОписаниеДанных.Отключено
	               |	И AINSYS_ОписаниеДанных.ПланСинхронизации = &ПланСинхронизации
	               |	И AINSYS_ОписаниеДанных.ОтправлятьДанныеКорУзлу";
	Запрос.УстановитьПараметр("ПланСинхронизации", спрПланСинхронизации);
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		РезультатОтправки = Справочники.AINSYS_ОписаниеДанных.ОтправитьДанныеКорУзлу(Выборка.Ссылка);
	КонецЦикла;
КонецПроцедуры

#КонецОбласти
