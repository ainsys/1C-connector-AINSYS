#Область ОбщегоНазначения

Процедура ЗаписатьОшибкуВЖурнал(спрОписаниеДанных, ТекстОшибки)
	Запись = РегистрыСведений.AINSYS_Журнал.СоздатьМенеджерЗаписи();
	Запись.ПравилоОбмена = спрОписаниеДанных;
	Запись.ДатаСобытия = ТекущаяДата();
	Запись.Ошибка = ТекстОшибки;
	Запись.Записать(Истина);
КонецПроцедуры

Функция ТаблицаЗначенийВТаблицуХТМЛ(ТабЗначений,СтруктураПараметрыТаблицыХТМЛ = Неопределено) Экспорт
	
	//СтруктураПараметрыТаблицыХТМЛ
	//
	//Общие параметры:
	//СтруктураПараметрыТаблицыХТМЛ.ШиринаТаблицы - общая ширина таблица
	//СтруктураПараметрыТаблицыХТМЛ.ЦветШапки - цвет шапки таблицы пример "eadbaf"
	//СтруктураПараметрыТаблицыХТМЛ.ПунктПорядкуИспользуется - по умолчанию ЛОЖЬ
	//
	//Индивиуальные для каждой колонки:
	//СтруктураПараметрыТаблицыХТМЛ.Заголовок1 - заголовок для первой колонки, цифра на конце обознает номер колонки (не с нуля)
	//СтруктураПараметрыТаблицыХТМЛ.Ширина1 - ширина для первой колонки, цифра на конце обознает номер колонки (не с нуля)
	//СтруктураПараметрыТаблицыХТМЛ.Положение1 - отвечает за положение текста в колонке (по умол. лево), передовать "center" или "right"
	
	МассивИменКолонок = Новый Массив;
	
	Если ТипЗнч(СтруктураПараметрыТаблицыХТМЛ) <> Тип("Структура") Тогда
		СтруктураПараметрыТаблицыХТМЛ = Новый Структура;
	КонецЕсли;
				
	КоличествоКолонок = ТабЗначений.Колонки.Количество();
	ПунктПорядкуИспользуется = ?(СтруктураПараметрыТаблицыХТМЛ.Свойство("ПунктПорядкуИспользуется"),СтруктураПараметрыТаблицыХТМЛ.ПунктПорядкуИспользуется,ЛОЖЬ);	
	
	Если КоличествоКолонок < 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
			
	ЦветШапки = ?(СтруктураПараметрыТаблицыХТМЛ.Свойство("ЦветШапки")," bgcolor=""#" + СтруктураПараметрыТаблицыХТМЛ.ЦветШапки + """","");
	ШиринаТаблицы = ?(СтруктураПараметрыТаблицыХТМЛ.Свойство("ШиринаТаблицы")," style=""width:" + СтруктураПараметрыТаблицыХТМЛ.ШиринаТаблицы + "px""",""); 
	ТаблицаХТМЛ = "<table border=""1"" cellpadding=""1"" cellspacing=""0"" " + ШиринаТаблицы + ">
				|<tbody>
				|<tr>";
	
	//Первым выводим столбик П/П если он задан в шапку
	Если ПунктПорядкуИспользуется Тогда
		ТаблицаХТМЛ = ТаблицаХТМЛ + "
				|<td" + ЦветШапки + " style=""width:30px"" align=""center"">п/п</td>";	
	КонецЕсли;
	
	//Формируем шапку
	Для Счетчик = 1 по КоличествоКолонок Цикл
		ИмяСвойстваШирина = "Ширина" + Счетчик;
		ШиринаСтолбца = ?(СтруктураПараметрыТаблицыХТМЛ.Свойство(ИмяСвойстваШирина)," style=""width:" + СтруктураПараметрыТаблицыХТМЛ[ИмяСвойстваШирина] + "px""","");
		ИмяКолонки = ТабЗначений.Колонки[Счетчик-1].Имя;
		ИмяСвойстваЗаголовок = "Заголовок" + Счетчик;
		ЗаголовокКолонки = ?(СтруктураПараметрыТаблицыХТМЛ.Свойство(ИмяСвойстваЗаголовок),СтруктураПараметрыТаблицыХТМЛ[ИмяСвойстваЗаголовок],ИмяКолонки);
		ТаблицаХТМЛ = ТаблицаХТМЛ + " 
				|<td" + ЦветШапки + ШиринаСтолбца + " align=""center"">" + ЗаголовокКолонки + "</td>";	
		МассивИменКолонок.Добавить(ИмяКолонки);
	КонецЦикла;
	ТаблицаХТМЛ = ТаблицаХТМЛ + "
				|</tr>";
	
	//Заполняем таблицу	
	ПунктПорядку = 0;
	Для каждого СтрокаТаблицы Из ТабЗначений Цикл
		ПунктПорядку = ПунктПорядку + 1;
		ТаблицаХТМЛ = ТаблицаХТМЛ + "
				|<tr>" + ?(ПунктПорядкуИспользуется, Символы.ПС + "<td align=""center"">" + ПунктПорядку + "</td>","") + "";
		Для Счетчик = 0 по КоличествоКолонок - 1 Цикл
			ИмяСвойстваПоложение = "Положение" + Строка(Счетчик + 1);
			Положение = " align=""" + ?(СтруктураПараметрыТаблицыХТМЛ.Свойство(ИмяСвойстваПоложение),СтруктураПараметрыТаблицыХТМЛ[ИмяСвойстваПоложение],"left") + """";
			ТаблицаХТМЛ = ТаблицаХТМЛ + "
				|<td " + Положение + ">" + СтрокаТаблицы[МассивИменКолонок[Счетчик]] + "</td>";			
		КонецЦикла;				
		ТаблицаХТМЛ = ТаблицаХТМЛ + "
				|</tr>";
	КонецЦикла;	
	
	ТаблицаХТМЛ = ТаблицаХТМЛ + " 
				|</tbody>
				|</table>";
	
	Возврат ТаблицаХТМЛ;

КонецФункции

Функция ДеревоЗначенийВТаблицуХТМЛ(ДеревоЗначений, Колонки, СтруктураПараметрыТаблицыХТМЛ = Неопределено) Экспорт
	
	//СтруктураПараметрыТаблицыХТМЛ
	//
	//Общие параметры:
	//СтруктураПараметрыТаблицыХТМЛ.ШиринаТаблицы - общая ширина таблица
	//СтруктураПараметрыТаблицыХТМЛ.ЦветШапки - цвет шапки таблицы пример "eadbaf"
	//СтруктураПараметрыТаблицыХТМЛ.ПунктПорядкуИспользуется - по умолчанию ЛОЖЬ
	//
	//Индивиуальные для каждой колонки:
	//СтруктураПараметрыТаблицыХТМЛ.Заголовок1 - заголовок для первой колонки, цифра на конце обознает номер колонки (не с нуля)
	//СтруктураПараметрыТаблицыХТМЛ.Ширина1 - ширина для первой колонки, цифра на конце обознает номер колонки (не с нуля)
	//СтруктураПараметрыТаблицыХТМЛ.Положение1 - отвечает за положение текста в колонке (по умол. лево), передовать "center" или "right"
	
	МассивИменКолонок = Новый Массив;
	
	Если ТипЗнч(СтруктураПараметрыТаблицыХТМЛ) <> Тип("Структура") Тогда
		СтруктураПараметрыТаблицыХТМЛ = Новый Структура;
	КонецЕсли;
				
	КоличествоКолонок = Колонки.Количество();
	ПунктПорядкуИспользуется = ?(СтруктураПараметрыТаблицыХТМЛ.Свойство("ПунктПорядкуИспользуется"),СтруктураПараметрыТаблицыХТМЛ.ПунктПорядкуИспользуется,ЛОЖЬ);	
	
	Если КоличествоКолонок < 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
			
	ЦветШапки = ?(СтруктураПараметрыТаблицыХТМЛ.Свойство("ЦветШапки")," bgcolor=""#" + СтруктураПараметрыТаблицыХТМЛ.ЦветШапки + """","");
	ШиринаТаблицы = ?(СтруктураПараметрыТаблицыХТМЛ.Свойство("ШиринаТаблицы")," style=""width:" + СтруктураПараметрыТаблицыХТМЛ.ШиринаТаблицы + "px""",""); 
	ТаблицаХТМЛ = "<table border=""1"" cellpadding=""1"" cellspacing=""0"" " + ШиринаТаблицы + ">
				|<tbody>
				|<tr>";
	
	//Первым выводим столбик П/П если он задан в шапку
	Если ПунктПорядкуИспользуется Тогда
		ТаблицаХТМЛ = ТаблицаХТМЛ + "
				|<td" + ЦветШапки + " style=""width:30px"" align=""center"">п/п</td>";	
	КонецЕсли;
	
	//Формируем шапку
	Для Счетчик = 1 по КоличествоКолонок Цикл
		ИмяСвойстваШирина = "Ширина" + Счетчик;
		ШиринаСтолбца = ?(СтруктураПараметрыТаблицыХТМЛ.Свойство(ИмяСвойстваШирина)," style=""width:" + СтруктураПараметрыТаблицыХТМЛ[ИмяСвойстваШирина] + "px""","");
		ИмяКолонки = Колонки[Счетчик-1].Имя;
		ИмяСвойстваЗаголовок = "Заголовок" + Счетчик;
		ЗаголовокКолонки = ?(СтруктураПараметрыТаблицыХТМЛ.Свойство(ИмяСвойстваЗаголовок),СтруктураПараметрыТаблицыХТМЛ[ИмяСвойстваЗаголовок],ИмяКолонки);
		ТаблицаХТМЛ = ТаблицаХТМЛ + " 
				|<td" + ЦветШапки + ШиринаСтолбца + " align=""center"">" + ЗаголовокКолонки + "</td>";	
		МассивИменКолонок.Добавить(ИмяКолонки);
	КонецЦикла;
	ТаблицаХТМЛ = ТаблицаХТМЛ + "
				|</tr>";
	
	//Заполняем таблицу	
	ПунктПорядку = 0;
	Для каждого СтрокаТаблицы Из ДеревоЗначений.Строки Цикл
		ПунктПорядку = ПунктПорядку + 1;
		ТаблицаХТМЛ = ТаблицаХТМЛ + "
				|<tr>" + ?(ПунктПорядкуИспользуется, Символы.ПС + "<td align=""center"">" + ПунктПорядку + "</td>","") + "";
		Для Счетчик = 0 по КоличествоКолонок - 1 Цикл
			ИмяСвойстваПоложение = "Положение" + Строка(Счетчик + 1);
			Положение = " align=""" + ?(СтруктураПараметрыТаблицыХТМЛ.Свойство(ИмяСвойстваПоложение),СтруктураПараметрыТаблицыХТМЛ[ИмяСвойстваПоложение],"left") + """";
			ТаблицаХТМЛ = ТаблицаХТМЛ + "
				|<td " + Положение + ">" + СтрокаТаблицы[МассивИменКолонок[Счетчик]] + "</td>";			
		КонецЦикла;
		ТаблицаХТМЛ = ТаблицаХТМЛ + "
				|</tr>";
		Если СтрокаТаблицы.Строки.Количество() > 0 Тогда
			ВложенныеСтроки = ДеревоЗначенийВТаблицуХТМЛ(СтрокаТаблицы, Колонки, СтруктураПараметрыТаблицыХТМЛ);
			ТаблицаХТМЛ = ТаблицаХТМЛ + "<tr>" + ВложенныеСтроки + "
					|</tr>";
		КонецЕсли;
	КонецЦикла;	
	
	ТаблицаХТМЛ = ТаблицаХТМЛ + " 
				|</tbody>
				|</table>";
	
	Возврат ТаблицаХТМЛ;

КонецФункции

// Возврашает структуру с двумя значениями
Функция ПолучитьСтруктуруСМакетомТД()
	тд = Новый ТабличныйДокумент;
	обл = тд.Область("R1C1");
	Граница = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная);
	обл.ГраницаСверху = Граница;
	обл.ГраницаСлева = Граница;
	обл.ГраницаСправа = Граница;
	обл.ГраницаСнизу = Граница;
	обл.Текст = "";
	
	стркМакет = Новый Структура("Ширина, Макет", 10, тд);
	Возврат стркМакет;
КонецФункции

Процедура ВывестиЗначениеСтруктурыВТД(тд, ВыводимоеЗначение, ключЗначение, стркПолей, Уровень)
	зн = Неопределено;
	ВыводимоеЗначение.Свойство(ключЗначение.Ключ, зн);
	
	Если ТипЗнч(зн) = Тип("Структура") ИЛИ ТипЗнч(зн) = Тип("Массив") Тогда
		Если зн.Количество() > 0 Тогда
			тдПодчиненный = СтруктуруМассивВТабличныйДокумент(зн, стркПолей, Уровень + 1);
			тд.Вывести(тдПодчиненный, Уровень);
		КонецЕсли;
	ИначеЕсли зн = Неопределено Тогда // пустая ячейки
		ПустойТД = Новый ТабличныйДокумент;
		обл = ПустойТД.Область("R1C1");
		обл.Текст = "";
		тд.Присоединить(ПустойТД);
	Иначе
		ВывестиЗначениеВТД(тд, зн, ключЗначение.Значение, Истина);
	КонецЕсли;
КонецПроцедуры

Процедура ВывестиЗначениеВТД(тд, зн, стркПолей, Присоединить = Ложь)
	обл = стркПолей.Макет.Область("R1C1");
	Если ТипЗнч(зн) = Тип("Число") Тогда
		обл.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
	Иначе
		обл.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Лево;
	КонецЕсли;
	обл.Текст = Строка(зн);
	ДлинаСтроки = СтрДлина(обл.Текст);
	стркПолей.Ширина = ?(ДлинаСтроки > 50, 50, ДлинаСтроки);
	Если Присоединить Тогда
		тд.Присоединить(стркПолей.Макет);
	Иначе
		тд.Вывести(стркПолей.Макет);
	КонецЕсли;
КонецПроцедуры

Функция СтруктуруМассивВТабличныйДокумент(ВыводимоеЗначение, стркПолей = Неопределено, Уровень = 0) Экспорт
	тд = Новый ТабличныйДокумент;
	Если стркПолей = Неопределено Тогда
		стркПолей = Новый Структура("БезымянноеПоле", ПолучитьСтруктуруСМакетомТД());
		Если Уровень = 0 Тогда
			тд.Вывести(стркПолей.БезымянноеПоле.Макет); // Первая строка пустая
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(ВыводимоеЗначение) = Тип("Структура") Тогда
		// Сначала выведем поля, которые уже выводились
		Для Каждого ключЗначение из стркПолей Цикл
			ВывестиЗначениеСтруктурыВТД(тд, ВыводимоеЗначение, ключЗначение, стркПолей, Уровень);
		КонецЦикла;
		
		// затем поля которые ранее не встречались
		Для Каждого ВыводимыеКлючЗначение из ВыводимоеЗначение Цикл
			стркМакет = Неопределено;
			Если НЕ стркПолей.Свойство(ВыводимыеКлючЗначение.Ключ, стркМакет) Тогда
				стркПолей.Вставить(ВыводимыеКлючЗначение.Ключ, ПолучитьСтруктуруСМакетомТД());
				Для Каждого ключЗначение из стркПолей Цикл
					Если ключЗначение.Ключ = ВыводимыеКлючЗначение.Ключ Тогда
						ВывестиЗначениеСтруктурыВТД(тд, ВыводимоеЗначение, ключЗначение, стркПолей, Уровень);
						Прервать
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(ВыводимоеЗначение) = Тип("Массив") Тогда
		Для Каждого зн из ВыводимоеЗначение Цикл
			Если ТипЗнч(зн) = Тип("Структура") ИЛИ ТипЗнч(зн) = Тип("Массив") Тогда
				тдПодчиненный = СтруктуруМассивВТабличныйДокумент(зн, стркПолей, Уровень + 1);
				тд.Вывести(тдПодчиненный, Уровень);
			Иначе // Просто знгачение из массива
				ВывестиЗначениеВТД(тд, зн, стркПолей)
			КонецЕсли;
		КонецЦикла;
	Иначе // Просто знгачение из массива
		ВывестиЗначениеВТД(тд, зн, стркПолей)
	КонецЕсли;
	
	Возврат тд;
КонецФункции

Процедура ВыолнитьСкриптОбработкиВыгрузки(ЭтоПравило, ВыборкаВыгрузки, Скрипт, Параметры)
	Выполнить(Скрипт);
КонецПроцедуры

// Простейшая попытка ограничить выборку
// После последнего слова Выбрать добавим Первые ххх
// Алгоритм может ошибаться, напрмер, на вложенных запросах или на имени поля, которое начинается с Выбрать
// Надеемся, что текст вложенного запроса не будет начинаться с новой строки, а слово Выбрать в имени поля никто не додумается использовать
// если есть соединения, то ограничивать нет смысла. Неизвестно сколько строк будет в результате
Функция ОграничитьЗапрос(ТекстЗапроса, Количество, Смещение)
	ЧислоСтрок = СтрЧислоСтрок(ТекстЗапроса);
	НомерИсправляемойСтроки = 0;
	Для поз = 1 По ЧислоСтрок Цикл
		текСтрока = нрег(СокрЛП(СтрПолучитьСтроку(ТекстЗапроса, поз)));
		Если стрНайти(текСтрока, " соединение ") ИЛИ стрНайти(текСтрока, " join ") Тогда
			НомерИсправляемойСтроки = 0;
			Прервать
		ИначеЕсли (СтрНачинаетсяС(текСтрока, "выбрать") ИЛИ СтрНачинаетсяС(текСтрока, "select")) И
			стрНайти(текСтрока, "первые") = 0 и стрНайти(текСтрока, "top") = 0 Тогда
			НомерИсправляемойСтроки = поз;
		КонецЕсли;
	КонецЦикла;
	
	Если НомерИсправляемойСтроки = 0 Тогда
		Возврат ТекстЗапроса;
	КонецЕсли;
	
	стрРезультат = "";
	
	Для поз = 1 По ЧислоСтрок Цикл
		Если поз = НомерИсправляемойСтроки Тогда
			текСтрока = нрег(СокрЛП(СтрПолучитьСтроку(ТекстЗапроса, поз)));
			Если СтрНачинаетсяС(текСтрока, "выбрать") Тогда
				текСтрока = Сред(текСтрока, 8) + "Выбрать Первые " + xmlСтрока(Количество + Смещение) + " ";
			ИначеЕсли СтрНачинаетсяС(текСтрока, "select") Тогда
				текСтрока = Сред(текСтрока, 7) + "Select top " + xmlСтрока(Количество + Смещение) + " ";
			КонецЕсли;
		Иначе
			текСтрока = СтрПолучитьСтроку(ТекстЗапроса, поз);
		КонецЕсли;
		стрРезультат = стрРезультат + "
			|" + текСтрока;
	КонецЦикла;
	Возврат стрРезультат;
	
КонецФункции

// Исполняет схему компоновки данных
// Параметры:
//		СКД - СхемаКомпоновкиДанных - что собственно надо исполнить
// Возвращаемое значение:
//		МакетКомпоновкиДанных - МакетКомпоновкиДанных - он может вывести результат в табличный документ или в коллекцию значений
Функция ВыполнитьСКД(СКД, ВыводитьВКоллекциюЗначений = Ложь, Количество = 0, Смещение = 0, сзСсылки = Неопределено)
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	
	Если ТипЗнч(сзСсылки) = Тип("СписокЗначений") Тогда
		ПолеСсылка = Новый ПолеКомпоновкиДанных("Ссылка");
		
		ЭлементОтбора = СКД.НастройкиПоУмолчанию.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбора.ЛевоеЗначение = ПолеСсылка;
		ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
		ЭлементОтбора.Использование = Истина;
		ЭлементОтбора.ПравоеЗначение = сзСсылки;
	Иначе
		// Пытаемся ограничить выборку запросом
		Если Количество > 0 И СКД.НаборыДанных.Количество() = 1 И Не ПустаяСтрока(СКД.НаборыДанных[0].Запрос) Тогда
			СКД.НаборыДанных[0].Запрос = ОграничитьЗапрос(СКД.НаборыДанных[0].Запрос, Количество, Смещение);
		КонецЕсли;
	КонецЕсли;
	
	Если ВыводитьВКоллекциюЗначений Тогда
		ТипМакета = Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений");
	Иначе
		ТипМакета = Тип("ГенераторМакетаКомпоновкиДанных");
	КонецЕсли;
	
	Попытка
		МакетКомпоновкиДанных = КомпоновщикМакета.Выполнить(СКД, СКД.НастройкиПоУмолчанию, , , ТипМакета);
	Исключение
		Возврат ОписаниеОшибки();
	КонецПопытки;
	Возврат МакетКомпоновкиДанных;
КонецФункции

Функция ПолучитьВозвращаемуюСтруктуру() Экспорт
	стрРезультат = Новый Структура("Правило, Данные, СписокИзмененных, Ошибка");
	Возврат стрРезультат;
КонецФункции

// Возвращает структуру, которую надо использовать для отбора возвращаемых данных.
// Приводит полученную структуру к описанию полей. Значения в структуре используются для отбора данных
// Параметры:
//		СсылкаНаПравило - СправочникСсылка.AINSYS_ОписаниеДанных - правило по которому будут возвращаться данных.
//		ТекстВходящегоЗапроса - Строка - полученный json со структурой. Поля структуры должны совпадать с полями, описанными в правиле
Функция ПолучитьСтруктуруДляОтбора(СсылкаНаПравило, ВходящийЗапрос)
	стркОтбор = Новый Структура;
	стркПолученная = Неопределено;
	Если ПустаяСтрока(ВходящийЗапрос) Тогда
		Возврат стркОтбор;
	ИначеЕсли ТипЗнч(ВходящийЗапрос) = Тип("Строка") И Не ПустаяСтрока(ВходящийЗапрос) Тогда
		стркПолученная = AINSYS_сервер.ЗначениеИзJson(ВходящийЗапрос);
	Иначе
		стркПолученная = ВходящийЗапрос;
	КонецЕсли;
	
	Если стркПолученная <> Неопределено Тогда
		Для Каждого стрПоле из СсылкаНаПравило.ПоляОбъектаДанных Цикл
			Если стрПоле.Отключено ИЛИ стркПолученная.Свойство(стрПоле.ИмяПоля) = Ложь Тогда
				Продолжить;
			КонецЕсли;
			
			ОтбираемоеЗначение = AINSYS_сервер.ПровестиЗначениеКТипу(стркПолученная[стрПоле.ИмяПоля], стрПоле.ТипПоля);
			стркОтбор.Вставить(стрПоле.ИмяПоля, ОтбираемоеЗначение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат стркОтбор;
КонецФункции

Процедура УстановитьОтборСКД(СКД, стркОтбор)
	Для Каждого КлючЗначение из стркОтбор Цикл
		ПолеКомпоновки = Новый ПолеКомпоновкиДанных(КлючЗначение.Ключ);
		ЭлементОтбора = СКД.НастройкиПоУмолчанию.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбора.ЛевоеЗначение = ПолеКомпоновки;
		ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ЭлементОтбора.Использование = Истина;
		ЭлементОтбора.ПравоеЗначение = КлючЗначение.Значение;
	КонецЦикла;
КонецПроцедуры

Процедура СнятьФлагИзмененности(ссылкаНаПравило, СписокИзмененных) Экспорт
	стркРеквизитыПравила = AINSYS_сервер.ЗначенияРеквизитовОбъекта(СсылкаНаПравило, Новый Структура("ВедущийОбъектРегистрацииИзменений, УзелОбмена, ВидПланаОбмена"));
	УзелОбмена = AINSYS_сервер.ПолучитьСсылкуПоИД(стркРеквизитыПравила.УзелОбмена, стркРеквизитыПравила.ВидПланаОбмена);
	Если ЗначениеЗаполнено(УзелОбмена) и ТипЗнч(СписокИзмененных) = Тип("СписокЗначений") Тогда
		Для Каждого зн из СписокИзмененных Цикл
			ПланыОбмена.УдалитьРегистрациюИзменений(УзелОбмена, зн.Значение);
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

Функция ПолучитьПравилоПоНаименованию(имяПравила, спрПланСинхронизации)
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	AINSYS_ОписаниеДанных.Ссылка КАК Ссылка
	               |ИЗ
	               |	Справочник.AINSYS_ОписаниеДанных КАК AINSYS_ОписаниеДанных
	               |ГДЕ
	               |	AINSYS_ОписаниеДанных.Наименование = &Наименование
	               |	И AINSYS_ОписаниеДанных.ПланСинхронизации = &ПланСинхронизации";
	Запрос.УстановитьПараметр("Наименование", имяПравила);
	Запрос.УстановитьПараметр("ПланСинхронизации", спрПланСинхронизации);
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Количество() = 1 Тогда
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

#КонецОбласти

#Область Метаданные

// Возвращает описание в нужном формате
Функция ПолучитьОписаниеДанных(Ссылка, ТребуемыйФормат) Экспорт
	стркРезультат = Новый Структура("id, Наименование, Описание, ОтправлятьДанныеКорУзлу, ПоляОбъектаДанных",
										xmlСтрока(Ссылка), Ссылка.Наименование, Ссылка.Описание, Ссылка.ОтправлятьДанныеКорУзлу);
	дерево = AINSYS_сервер.ВыгрузитьТаблицуЗначенийВДеревоЗначений(Ссылка.ПоляОбъектаДанных.Выгрузить(), "КлючСтроки", "КлючРодителя");
	
	// удалим отключённые строки
	стркОтбор = Новый Структура("Отключено", Истина);
	масСтрок = дерево.Строки.НайтиСтроки(стркОтбор, Истина);
	Для каждого стрДерева из масСтрок Цикл
		Если стрДерева.Родитель = Неопределено Тогда
			дерево.Строки.Удалить(стрДерева);
		Иначе
			стрДерева.Родитель.Удалить(стрДерева);
		КонецЕсли;
	КонецЦикла;
	
	масКолонок = Новый Массив;	
	масКолонок.Добавить(дерево.Колонки.ИмяПоля);
	масКолонок.Добавить(дерево.Колонки.Описание);
	масКолонок.Добавить(дерево.Колонки.ТипПоля);
	масКолонок.Добавить(дерево.Колонки.ДлинаПоля);
	масКолонок.Добавить(дерево.Колонки.ТочностьПоля);
	масКолонок.Добавить(дерево.Колонки.Комментарий);
	стркРезультат.ПоляОбъектаДанных = AINSYS_сервер.ДеревоВМассив(дерево, масКолонок);
		
	Если ТребуемыйФормат = "структура" Тогда
		Возврат стркРезультат;
	ИначеЕсли ТребуемыйФормат = "json" Тогда
		резJSON = AINSYS_сервер.ЗначениеВjson(стркРезультат);
		Возврат резJSON;
		
	Иначе
		тдРезультат = СформироватьТабличныйДокументПоДеревуЗначений(Ссылка.ПоляОбъектаДанных.Выгрузить());
		
		Возврат тдРезультат;
	КонецЕсли;
КонецФункции

Функция ПолучитьОписаниеДанныхЧерезСКД(спрПланСинхронизации, ТребуемыйФормат) Экспорт
	
	РезультатВДерево = ТребуемыйФормат = "json" ИЛИ ТребуемыйФормат = "структура";
	Если РезультатВДерево Тогда
		СхемаКомпоновкиДанных = ПолучитьМакет("ОписаниеДляВнешнейСистемы");
	Иначе
		СхемаКомпоновкиДанных = ПолучитьМакет("ОписаниеВизуальное");
	Конецесли;
	ПараметрКлюч = СхемаКомпоновкиДанных.НастройкиПоУмолчанию.ПараметрыДанных.Элементы.Найти("ПланСинхронизации");
	ПараметрКлюч.Значение = спрПланСинхронизации;
	МакетКомпоновкиДанных = ВыполнитьСКД(СхемаКомпоновкиДанных, РезультатВДерево);
	
	Если ТипЗнч(МакетКомпоновкиДанных) = Тип("Строка") Тогда
		стркОшибка = Новый Структура("Ошибка", МакетКомпоновкиДанных);
		резJSON = AINSYS_сервер.ЗначениеВjson(стркОшибка);
		Возврат резJSON;
	КонецЕсли;
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновкиДанных, , , Истина);
		
	Если ТребуемыйФормат = "json" ИЛИ ТребуемыйФормат = "структура" Тогда
		
		Результат = Новый ДеревоЗначений;
		ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
		ПроцессорВывода.УстановитьОбъект(Результат);
		ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
		
		стркСтруктураОтчета = ПолучитьСтруктуруОтчета(СхемаКомпоновкиДанных.ВариантыНастроек[0].Настройки);
		МассивРезультат = AINSYS_сервер.ДеревоОтчетаВМассив(Результат, стркСтруктураОтчета);
		Если ТребуемыйФормат = "структура" Тогда
			Возврат МассивРезультат;
		Иначе
			резJSON = AINSYS_сервер.ЗначениеВjson(МассивРезультат);
			Возврат резJSON;
		КонецЕсли;
	Иначе

		тдРезультат = Новый ТабличныйДокумент;
		ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
		ПроцессорВывода.УстановитьДокумент(тдРезультат);
		Попытка
			ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
		Исключение
			обл = тдРезультат.Область("R1C1:R1C11");
			обл.Объединить();
			обл.Текст = ОписаниеОшибки();
			обл.ГоризонтальноеПоложение = ГоризонтальноеПоложение.ПоШирине;
			обл.ЦветТекста = ЦветаСтиля.ЦветОсобогоТекста;
		Конецпопытки;
		
		Возврат тдРезультат;
	КонецЕсли;
КонецФункции

Функция ПолучитьСтруктуруОтчета(дзСтруктура, ИмяПоля = "") Экспорт
	стркРезультат = Новый Структура("ПоляГруппировки, Имя, ТипПоля", "", "");
	стркРезультат.Имя = ?(ПустаяСтрока(ИмяПоля), дзСтруктура.ИмяПоля, ИмяПоля);
	Для Каждого стрСтруктура из дзСтруктура.Строки Цикл
		Если НЕ стрСтруктура.Отключено = Истина Тогда
			стркРезультат.ПоляГруппировки = стркРезультат.ПоляГруппировки + "," + Строка(стрСтруктура.ИмяПоля);
		КонецЕсли;
		Если стрСтруктура.Строки.Количество() > 0 Тогда
			ВложенныеПоля = ПолучитьСтруктуруОтчета(стрСтруктура);
			ВложенныеПоля.ТипПоля = стрСтруктура.ТипПоля;
			стркРезультат.Вставить(стрСтруктура.ИмяПоля, ВложенныеПоля);
		КонецЕсли;
	КонецЦикла;	
	стркРезультат.ПоляГруппировки = Сред(стркРезультат.ПоляГруппировки, 2);
	Возврат стркРезультат;
КонецФункции

// на каждом уровне может быть свой набор колонок.
// В дереве значений все колонки есть на всех уровнях. Нам так не надо.
Функция ПолучитьДеревоОтчета(Настройки, СтрокаВладелец = Неопределено) Экспорт
	ЭтоКорень = Ложь;
	Если СтрокаВладелец = Неопределено Тогда
		деревоРезультат = Новый ДеревоЗначений;
		деревоРезультат.Колонки.Добавить("ИмяПоля");
		деревоРезультат.Колонки.Добавить("ТипПоля");
		деревоРезультат.Колонки.Добавить("ОписаниеПоля");
		СтрокаВладелец = деревоРезультат;
		ЭтоКорень = Истина;
	КонецЕсли;
	
	Для Каждого СтруктураОтчета из Настройки.Структура Цикл
		Если ЭтоКорень Тогда
			СтрокаГруппы = СтрокаВладелец;
		Иначе
			СтрокаГруппы = СтрокаВладелец.Строки.Добавить();
			СтрокаГруппы.ИмяПоля = ?(ПустаяСтрока(СтруктураОтчета.Имя), "Строки", СтруктураОтчета.Имя);
			СтрокаГруппы.ТипПоля = Перечисления.AINSYS_ТипыДанных.Массив;
		КонецЕсли;
		
		Для Каждого ПолеГруппировки из СтруктураОтчета.ПоляГруппировки.Элементы Цикл
			Если ПолеГруппировки.Использование Тогда
				стрДерева = СтрокаГруппы.Строки.Добавить();
				стрДерева.ИмяПоля = ПолеГруппировки.Поле;
			КонецЕсли;
		КонецЦикла;
		
		Если СтруктураОтчета.Структура.Количество() > 0 Тогда
			ПолучитьДеревоОтчета(СтруктураОтчета, СтрокаГруппы);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрокаВладелец;
КонецФункции

#КонецОбласти

#Область ВыборкаДанных

Функция ПримерВыборки() Экспорт
	
	СхемаКомпоновкиДанных = ПолучитьМакет("ПримерСКД");
	МакетКомпоновкиДанных = ВыполнитьСКД(СхемаКомпоновкиДанных, Истина);
	
	Если ТипЗнч(МакетКомпоновкиДанных) = Тип("Строка") Тогда
		стркОшибка = Новый Структура("Ошибка", МакетКомпоновкиДанных);
		резJSON = AINSYS_сервер.ЗначениеВjson(стркОшибка);
		Возврат резJSON;
	КонецЕсли;
	
	стркСтруктураОтчета = ПолучитьСтруктуруОтчета(СхемаКомпоновкиДанных.ВариантыНастроек[0].Настройки);
	
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновкиДанных);

	Результат = Новый ДеревоЗначений;
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорВывода.УстановитьОбъект(Результат);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
	МассивРезультат = AINSYS_сервер.ДеревоОтчетаВМассив(Результат, стркСтруктураОтчета);
	резJSON = AINSYS_сервер.ЗначениеВjson(МассивРезультат);
	Возврат резJSON;
КонецФункции

Процедура ЗаполнитьМассивГруппировокМакета(ВладелецЧастиТела, МакетКомпоновкиДанных)
	Для Каждого ЧастьТела из ВладелецЧастиТела.Тело Цикл
		Если ТипЗнч(ЧастьТела) = Тип("ГруппировкаМакетаКомпоновкиДанных") Тогда
			
			ОписаниеМакетаОбласти = МакетКомпоновкиДанных.Макеты.Найти(ЧастьТела.Тело[0].Макет);
			НовыйПараметр = ОписаниеМакетаОбласти.Параметры.Добавить(Тип("ПараметрОбластиВыражениеКомпоновкиДанных"));
			НовыйПараметр.Имя = "AINSYS_ИмяГруппировки";
			НовыйПараметр.Выражение = """" + ЧастьТела.Идентификатор + """";
			
			Для Каждого Ячейка из ОписаниеМакетаОбласти.Макет.Ячейки Цикл
				Если Ячейка.Колонка = "AINSYS_ИмяГруппировки" Тогда
					Ячейка.Значение = Новый ПараметрКомпоновкиДанных("AINSYS_ИмяГруппировки");
					Прервать
				КонецЕсли;
			КонецЦикла;
			
			ЗаполнитьМассивГруппировокМакета(ЧастьТела, МакетКомпоновкиДанных);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ДобавитьКолонкуИменГруппировокССтруктуру(СтруктураНастроекОтчета)
	
	Для Каждого Группировка из СтруктураНастроекОтчета Цикл
		Если НЕ Группировка.Использование Тогда
			Продолжить
		КонецЕсли;
		ПолеГруппировкиКомпоновкиДанных = Группировка.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));
		ПолеГруппировкиКомпоновкиДанных.Использование = Истина;
		ПолеГруппировкиКомпоновкиДанных.Поле = Новый ПолеКомпоновкиДанных("AINSYS_ИмяГруппировки");
		
		Если Группировка.Структура.Количество() > 0 Тогда
			ДобавитьКолонкуИменГруппировокССтруктуру(Группировка.Структура)
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// добавляет в СКД
Процедура ДобавитьКолонкуИменГруппировок(СКД)
	
	// Вычислямое поле. Значение добавим потом
	ВычисляемоеПоле = СКД.ВычисляемыеПоля.Добавить();
	ВычисляемоеПоле.ПутьКДанным = "AINSYS_ИмяГруппировки";
	ВычисляемоеПоле.Выражение = """12345678901234567890123456789012345678901234567890""";
	// до жопы дверца это определение типа. Надо в само выражение заколотить достаточно длинную строку. Версия 8.3.16.1148
	ВычисляемоеПоле.ТипЗначения = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(50));
	
	ДобавитьКолонкуИменГруппировокССтруктуру(СКД.НастройкиПоУмолчанию.Структура);
Конецпроцедуры

Функция ПолучитьСписокИзмененныхОбъектов(СсылкаНаПравило)//, Количество, Смещение)
	сзРезультат = Новый СписокЗначений;
	стркРеквизитыПравила = AINSYS_сервер.ЗначенияРеквизитовОбъекта(СсылкаНаПравило, Новый Структура("ВедущийОбъектРегистрацииИзменений, УзелОбмена, ВидПланаОбмена"));
	УзелОбмена = AINSYS_сервер.ПолучитьСсылкуПоИД(стркРеквизитыПравила.УзелОбмена, стркРеквизитыПравила.ВидПланаОбмена);
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
					|	Т.Ссылка КАК Ссылка
					|ИЗ
					|	" + стркРеквизитыПравила.ВедущийОбъектРегистрацииИзменений + ".Изменения КАК Т
					|ГДЕ
					|	Т.Узел = &Узел
					|УПОРЯДОЧИТЬ ПО
					|	Ссылка";
	Запрос.УстановитьПараметр("Узел", УзелОбмена);
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		ЗаписьЖурналаРегистрации("ИМАГ", УровеньЖурналаРегистрации.Ошибка, ,, ОписаниеОшибки());
		Ошибка = "Ошибка получения списка изменённых объектов для правила " + Строка(СсылкаНаПравило);
		ЗаписатьОшибкуВЖурнал(СсылкаНаПравило, Ошибка);
		Возврат Ошибка;
	КонецПопытки;
	
	Пока Выборка.Следующий() Цикл
		сзРезультат.Добавить(Выборка.Ссылка);
	КонецЦикла;
	
	Возврат сзРезультат;
КонецФункции

Функция ПолучитьДанные(Ссылка, ПолучитьКакДерево = Ложь, Количество, Смещение, Измененные = Ложь, ВходящийЗапрос = "")
	стркРезультат = Новый Структура("ВыборкаВыгрузки, СписокИзмененных, Ошибка", , , "");
	стркРезультат.ВыборкаВыгрузки = Новый ДеревоЗначений;
	дзСтруктурыотчета = AINSYS_сервер.ВыгрузитьТаблицуЗначенийВДеревоЗначений(Ссылка.ПоляОбъектаДанных.Выгрузить(), "КлючСтроки", "КлючРодителя");
	стркСтруктураОтчета = ПолучитьСтруктуруОтчета(дзСтруктурыотчета, Ссылка.Наименование);
	
	стркОтбор = ПолучитьСтруктуруДляОтбора(Ссылка, ВходящийЗапрос);
	
	Если Измененные = Истина Тогда
		сзСсылки = ПолучитьСписокИзмененныхОбъектов(Ссылка);
		Если ТипЗнч(сзСсылки) = Тип("Строка") Тогда
			стркРезультат.Ошибка = сзСсылки;
			Возврат стркРезультат;
		КонецЕсли;
		стркРезультат.СписокИзмененных = сзСсылки;
	КонецЕсли;
	
	Если Ссылка.СпособВыборкиДанных = Перечисления.AINSYS_СпособВыбокиДанных.СКД Тогда
		
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(Ссылка.СКД);
		Попытка
			СКД = СериализаторXDTO.ПрочитатьXML(ЧтениеXML, Тип("СхемаКомпоновкиДанных"));
		Исключение
			Ошибка = ОписаниеОшибки();
		КонецПопытки;
		
		Если ПустаяСтрока(Ошибка) Тогда
			// Добавим отбор по входящим параметрам
			УстановитьОтборСКД(СКД, стркОтбор);
			
			ДобавитьКолонкуИменГруппировок(СКД);
			МакетКомпоновкиДанных = ВыполнитьСКД(СКД, Истина, Количество, Смещение, стркРезультат.СписокИзмененных);
			Если ТипЗнч(МакетКомпоновкиДанных) = Тип("Строка") Тогда
				стркРезультат.Ошибка = МакетКомпоновкиДанных;
			Иначе
				ЗаполнитьМассивГруппировокМакета(МакетКомпоновкиДанных, МакетКомпоновкиДанных);
			КонецЕсли;
			
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(стркРезультат.Ошибка) Тогда
			Возврат стркРезультат;
		КонецЕсли;
		
		ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
		ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновкиДанных);
		
		ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
		ПроцессорВывода.УстановитьОбъект(стркРезультат.ВыборкаВыгрузки);
		ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);

		// Если нужно вернуть только изменённые, то удалим из результата всё остальное
		ЕстьКолонкаСсылка = НЕ стркРезультат.ВыборкаВыгрузки.Колонки.Найти("Ссылка") = Неопределено;
		Если Измененные И ЕстьКолонкаСсылка Тогда
			масУдаляемых = Новый Массив;
			Для Каждого стрРезультата из стркРезультат.ВыборкаВыгрузки.Строки Цикл
				ЭлементСЗ = стркРезультат.СписокИзмененных.НайтиПоЗначению(стрРезультата.Ссылка);
				Если ЭлементСЗ = Неопределено Тогда
					масУдаляемых.Добавить(стрРезультата);
				КонецЕсли;
			КонецЦикла;
			
			Для Каждого стрКУдаленияю из масУдаляемых Цикл
				стркРезультат.ВыборкаВыгрузки.Строки.Удалить(стрКУдаленияю);
			КонецЦикла;
		КонецЕсли;

		Если Количество > 0 Тогда
			// отберём строки для постраничного просмотра
			масУдаляемых = Новый Массив;
			поз = 1;
			Послдедний = Смещение + Количество;
			Для Каждого стрРезультата из стркРезультат.ВыборкаВыгрузки.Строки Цикл
				Если поз <= Смещение ИЛИ поз > Послдедний Тогда
					масУдаляемых.Добавить(стрРезультата);
				КонецЕсли;
				поз = поз + 1;
			КонецЦикла;
			
			Для Каждого стрРезультата из масУдаляемых Цикл
				стркРезультат.ВыборкаВыгрузки.Строки.Удалить(стрРезультата);
			КонецЦикла;
			
			// удаляем из списка изменённых то чего нет в выборке
			Если ЕстьКолонкаСсылка И Измененные = Истина Тогда
				масУдаляемых = Новый Массив;
				Для Каждого ЭлементСЗ_Измененный из стркРезультат.СписокИзмененных Цикл
					Если стркРезультат.ВыборкаВыгрузки.Строки.Найти(ЭлементСЗ_Измененный.Значение, "Ссылка", Ложь) = Неопределено Тогда
						масУдаляемых.Добавить(ЭлементСЗ_Измененный);
					КонецЕсли;
				КонецЦикла;
				
				Для Каждого ЭлементСЗ_Измененный из масУдаляемых Цикл
					стркРезультат.СписокИзмененных.Удалить(ЭлементСЗ_Измененный);
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(Ссылка.ОбработкаВыгрузки) Тогда
		Параметры = Новый Структура("Количество, Смещение, сзСсылки, стркОтбор", Количество, Смещение, стркРезультат.СписокИзмененных, стркОтбор);
		// Если заполнение программное, то добавим колонку AINSYS_ИмяГруппировки. В СКД такая колонка добавляется в другом месте.
		Если стркРезультат.ВыборкаВыгрузки.Колонки.Найти("AINSYS_ИмяГруппировки") = Неопределено Тогда
			стркРезультат.ВыборкаВыгрузки.Колонки.Добавить("AINSYS_ИмяГруппировки");
		КонецЕсли;
		Попытка
			ВыолнитьСкриптОбработкиВыгрузки(Ссылка, стркРезультат.ВыборкаВыгрузки, Ссылка.ОбработкаВыгрузки, Параметры);
		Исключение
			стркРезультат.Ошибка = ОписаниеОшибки();
			ЗаписатьОшибкуВЖурнал(Ссылка, стркРезультат.Ошибка);
		КонецПопытки;
	КонецЕсли;
	
	Если ПолучитьКакДерево Тогда
		Возврат стркРезультат;
	Иначе
		стрк = AINSYS_сервер.ДеревоОтчетаВМассив(стркРезультат.ВыборкаВыгрузки, стркСтруктураОтчета);
		стркРезультат.ВыборкаВыгрузки = стрк[стркСтруктураОтчета.Имя]; // первый уровень не нужен. И так имя ясно
		
		Возврат стркРезультат;
	КонецЕсли;
КонецФункции

// Параметры:
//		ссылкаНаПравило - СправочникСсылка.AINSYS_ОписаниеДанных - правило выгрузки данных
//		Количество - Число - количество элементов, которые нужно вернуть
//		Смещение - Число - количество пропускаемых элементов
//		Измененные - Булево - если Истина, то требуется вернуть только изменившиеся объекты
//		ТекстВходящегоЗапроса - Строка - json со структурой. Поля должны совпададать с полями, возвращаемыми правилом. По значениям полей отбираются данные
Функция ПолучитьВыгружаемыеДанные(ссылкаНаПравило, ФорматДанных, Количество, Смещение, Измененные, ВходящийЗапрос = "") Экспорт
	стркРезультат = ПолучитьВозвращаемуюСтруктуру();
	
	стркВыборка = ПолучитьДанные(ссылкаНаПравило, НЕ ФорматДанных = "json", Количество, Смещение, Измененные, ВходящийЗапрос);
	
	стркРезультат.СписокИзмененных = стркВыборка.СписокИзмененных;
	стркРезультат.Правило = xmlСтрока(ссылкаНаПравило);
	Если Не ПустаяСтрока(стркВыборка.Ошибка) Тогда
		стркРезультат.Ошибка = стркВыборка.Ошибка;
		Возврат стркРезультат;
	КонецЕсли;
	
	Если ФорматДанных = "json" Тогда
		стркРезультат.Данные = стркВыборка.ВыборкаВыгрузки;
	Иначе
		тдРезультат = СформироватьТабличныйДокументПоДеревуЗначений(стркВыборка.ВыборкаВыгрузки);
		стркРезультат.Данные = тдРезультат;
	КонецЕсли;
	
	Возврат стркРезультат;
КонецФункции

#КонецОбласти

#Область ДеревоСКД
// http://disk1c.ru/2016/07/26/%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%B0-%D0%B2-%D1%81%D0%BA%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0-%D0%B5%D0%B3%D0%BE-%D0%B2-%D0%B4/
// https://start1c.blogspot.com/2017/02/blog-post.html
Функция СформироватьТабличныйДокументПоДеревуЗначений(ДанныеДерева, ВыбранныеПоляДерева = Неопределено, ПолеИД = "", ПолеРодительИД = "") Экспорт
	//ТабДокумент = Новый ТабличныйДокумент;
	
	ИсточникиДанных = Новый Структура("ДанныеДерева", ДанныеДерева);
	СхемаКомпоновки = ПолучитьСхемуКомпоновкиПоДереву(ДанныеДерева, ВыбранныеПоляДерева, ПолеИД, ПолеРодительИД);
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновки, СхемаКомпоновки.НастройкиПоУмолчанию);
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных; 
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки, ИсточникиДанных);
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	//ПроцессорВывода.УстановитьДокумент(ТабДокумент);
	ПроцессорВывода.УстановитьДокумент();
	Попытка
		ТабДокумент = ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	Исключение
		ТабДокумент = Новый ТабличныйДокумент;
		обл = ТабДокумент.Область("R" + xmlСтрока(ТабДокумент.ВысотаТаблицы + 2) + "C1:R" + xmlСтрока(ТабДокумент.ВысотаТаблицы + 2) + "C16");
		обл.Объединить();
		Шрифт = Новый Шрифт(, 12);
		обл.Шрифт = Шрифт;
		обл.РазмещениеТекста = ТипРазмещенияТекстаТабличногоДокумента.Переносить;
		обл.Текст = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат ТабДокумент;
КонецФункции

Функция ПолучитьСхемуКомпоновкиПоДереву(ДанныеДерева, ВыбранныеПоляДерева = Неопределено, ПолеИД = "", ПолеРодительИД = "")
	
	Если ВыбранныеПоляДерева = Неопределено Тогда
		ВыбранныеПоляДерева = Новый Массив;
	КонецЕсли;
	ЗаполнитьВыбранныеПоляДерева = НЕ ВыбранныеПоляДерева.Количество();
	
	СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
	НастройкиКомпоновки = СхемаКомпоновки.НастройкиПоУмолчанию;
	
	ИсточникДанных = СхемаКомпоновки.ИсточникиДанных.Добавить();
	ИсточникДанных.Имя = "ИсточникДанных";
	ИсточникДанных.ТипИсточникаДанных = "Local";  
	
	НаборДанных = СхемаКомпоновки.НаборыДанных.Добавить(Тип("НаборДанныхОбъектСхемыКомпоновкиДанных"));
	НаборДанных.ИмяОбъекта = "ДанныеДерева";
	НаборДанных.Имя = "НаборДанных";
	НаборДанных.ИсточникДанных = "ИсточникДанных"; 
	
	Для Каждого КолонкаДерева Из ДанныеДерева.Колонки Цикл
		
		ИмяПоля = КолонкаДерева.Имя;
		ЗаголовокПоля = КолонкаДерева.Заголовок;
		
		ПолеНабора = НаборДанных.Поля.Добавить(Тип("ПолеНабораДанныхСхемыКомпоновкиДанных"));
		ПолеНабора.Заголовок = ЗаголовокПоля;
		ПолеНабора.Поле = ИмяПоля;
		
		Если ЗаполнитьВыбранныеПоляДерева И НЕ (ИмяПоля = ПолеИД ИЛИ ИмяПоля = ПолеРодительИД) Тогда
			ВыбранныеПоляДерева.Добавить(Новый Структура("Имя, Заголовок", ИмяПоля, ЗаголовокПоля));
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(ПолеИД) И Не ПустаяСтрока(ПолеРодительИД) Тогда
		СвязьНабора = СхемаКомпоновки.СвязиНаборовДанных.Добавить();
		СвязьНабора.НаборДанныхИсточник = "НаборДанных";
		СвязьНабора.НаборДанныхПриемник = "НаборДанных";
		СвязьНабора.ВыражениеИсточник = ПолеИД;
		СвязьНабора.ВыражениеПриемник = ПолеРодительИд;
		СвязьНабора.НачальноеВыражение = "0";
	КонецЕсли;
	
	ВыбранныеПоля = НастройкиКомпоновки.Выбор.Элементы;
	Для Каждого ПолеДерева Из ВыбранныеПоляДерева Цикл
		ПолеОтчет = ВыбранныеПоля.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ПолеОтчет.Поле = Новый ПолеКомпоновкиДанных(ПолеДерева.Имя);
		ПолеОтчет.Заголовок = ПолеДерева.Заголовок;
	КонецЦикла;
	
	СтруктураГруппировки = НастройкиКомпоновки.Структура; 
	ЭлементГруппировки = СтруктураГруппировки.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	ЭлементГруппировки.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	
	Возврат СхемаКомпоновки; 
	
КонецФункции// ПолучитьСхемуКомпоновкиПоДереву()

#КонецОбласти

#Область ЗаписьДанных

Функция ПолучитьНовыеПоля(ДеревоПолейОбъекта, стркПолученная)
	стркНовыеПоля = Новый Структура;
	
	Для Каждого КлючЗначение из стркПолученная Цикл
		
		Если ТипЗнч(ДеревоПолейОбъекта) = Тип("ДеревоЗначений") ИЛИ ТипЗнч(ДеревоПолейОбъекта) = Тип("СтрокаДереваЗначений") Тогда
			НайденнаяСтрокаДерева = ДеревоПолейОбъекта.Строки.Найти(КлючЗначение.Ключ, "ИмяПоля");
		Иначе
			НайденнаяСтрокаДерева = Неопределено;
		КонецЕсли;
		
		Если НайденнаяСтрокаДерева = Неопределено И НЕ стркНовыеПоля.Свойство(КлючЗначение.Ключ) Тогда // строки нет в дереве и такое поле мы ещё не обрабатывали
			Если ТипЗнч(КлючЗначение.Значение) = Тип("Массив") И ТипЗнч(КлючЗначение.Значение[0]) = Тип("Структура") Тогда
				ВложенныеПоля = ПолучитьНовыеПоля(Неопределено, ключЗначение.Значение[0]);
				Если ВложенныеПоля.Количество() > 0 Тогда
					мас = Новый Массив;
					мас.Добавить(ВложенныеПоля);
					стркНовыеПоля.Вставить(КлючЗначение.Ключ, мас);
				КонецЕсли;
			ИначеЕсли ТипЗнч(КлючЗначение.Значение) = Тип("Структура") Тогда
				ВложенныеПоля = ПолучитьНовыеПоля(Неопределено, КлючЗначение.Значение);
				Если ВложенныеПоля.Количество() > 0 Тогда
					стркНовыеПоля.Вставить(КлючЗначение.Ключ, ВложенныеПоля);
				КонецЕсли;
			Иначе
				стркНовыеПоля.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
			КонецЕсли;
		ИначеЕсли ТипЗнч(КлючЗначение.Значение) = Тип("Массив") И ТипЗнч(КлючЗначение.Значение[0]) = Тип("Структура") Тогда
			ВложенныеПоля = ПолучитьНовыеПоля(Неопределено, ключЗначение.Значение[0]);
			Если ВложенныеПоля.Количество() > 0 Тогда
				мас = Новый Массив;
				мас.Добавить(ВложенныеПоля);
				стркНовыеПоля.Вставить(КлючЗначение.Ключ, мас);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат стркНовыеПоля;
КонецФункции

Процедура ОтметитьНовыеПоля(спрОписаниеДанных, ПолученныеДанные, стркВходящийЗапрос)
	
	ДеревоПолейОбъекта = AINSYS_сервер.ВыгрузитьТаблицуЗначенийВДеревоЗначений(спрОписаниеДанных.ПоляОбъектаДанных.Выгрузить(), "КлючСтроки", "КлючРодителя");
	Если ТипЗнч(ПолученныеДанные) = Тип("Структура") Тогда
		стркНовыеПоля = ПолучитьНовыеПоля(ДеревоПолейОбъекта, ПолученныеДанные);
	ИначеЕсли ТипЗнч(ПолученныеДанные) = Тип("Массив") И ПолученныеДанные.Количество() > 0 И ТипЗнч(ПолученныеДанные[0]) = Тип("Структура") Тогда
		стркНовыеПоля = ПолучитьНовыеПоля(ДеревоПолейОбъекта, ПолученныеДанные[0]);
	КонецЕсли;
	
	обОписаниеДанных = спрОписаниеДанных.ПолучитьОбъект();
	обОписаниеДанных.ДатаСверкиПолей = ТекущаяДата();
	обОписаниеДанных.Записать();
	Если стркНовыеПоля.Количество() > 0 Тогда
		Запись = РегистрыСведений.AINSYS_НовыеПоля.СоздатьМенеджерЗаписи();
		Запись.ПравилоОбмена = спрОписаниеДанных;
		Запись.ДатаПолучения = ТекущаяДата();
		Запись.ПолученныеДанные = AINSYS_сервер.ЗначениеВjson(стркВходящийЗапрос);
		Запись.НовыеПоля = AINSYS_сервер.ЗначениеВjson(стркНовыеПоля);
		Запись.Записать(Истина);
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьЗагружаемуюСтруктуру(ДеревоПолейОбъекта, стркПолученная)
	стркДляЗагрузки = Новый Структура;
	Для Каждого стрПоле из ДеревоПолейОбъекта.Строки Цикл
		Если стрПоле.Отключено ИЛИ стркПолученная.Свойство(стрПоле.ИмяПоля) = Ложь Тогда
			Продолжить;
		КонецЕсли;
		
		Если стрПоле.ТипПоля = Перечисления.AINSYS_ТипыДанных.Булево
				ИЛИ стрПоле.ТипПоля = Перечисления.AINSYS_ТипыДанных.Строка
				ИЛИ стрПоле.ТипПоля = Перечисления.AINSYS_ТипыДанных.Дата
				ИЛИ стрПоле.ТипПоля = Перечисления.AINSYS_ТипыДанных.Ссылка
				ИЛИ стрПоле.ТипПоля = Перечисления.AINSYS_ТипыДанных.Число Тогда
			ЗначениеПоля = AINSYS_сервер.ПровестиЗначениеКТипу(стркПолученная[стрПоле.ИмяПоля], стрПоле.ТипПоля);
			стркДляЗагрузки.Вставить(стрПоле.ИмяПоля, ЗначениеПоля);
		ИначеЕсли стрПоле.ТипПоля = Перечисления.AINSYS_ТипыДанных.Объект И ТипЗнч(стркПолученная[стрПоле.ИмяПоля]) = Тип("Структура") Тогда
			ЗначениеПоля = ПолучитьЗагружаемуюСтруктуру(ДеревоПолейОбъекта, стркПолученная[стрПоле.ИмяПоля]);
			стркДляЗагрузки.Вставить(стрПоле.ИмяПоля, ЗначениеПоля);
		ИначеЕсли стрПоле.ТипПоля = Перечисления.AINSYS_ТипыДанных.Массив И ТипЗнч(стркПолученная[стрПоле.ИмяПоля]) = Тип("Массив") Тогда
			мас = Новый Массив;
			Для Каждого зн из стркПолученная[стрПоле.ИмяПоля] Цикл
				Если ТипЗнч(зн) = Тип("Структура") Тогда
					ЗначениеПоля = ПолучитьЗагружаемуюСтруктуру(стрПоле, зн);
					мас.Добавить(ЗначениеПоля);
				КонецЕсли;
			КонецЦикла;
			стркДляЗагрузки.Вставить(стрПоле.ИмяПоля, мас);
		ИначеЕсли стрПоле.ТипПоля = Перечисления.AINSYS_ТипыДанных.Base64
				И ТипЗнч(стркПолученная[стрПоле.ИмяПоля]) = Тип("Строка")
				И СтрДлина(стркПолученная[стрПоле.ИмяПоля]) > 4 Тогда
			стркДляЗагрузки.Вставить(стрПоле.ИмяПоля, Base64Значение(стркПолученная[стрПоле.ИмяПоля]));
			КонецЕсли;
	КонецЦикла;
	
	Возврат стркДляЗагрузки;
КонецФункции

Функция ПривестиДанныеКЗагружаемомуВиду(спрОписаниеДанных, ПолученныеДанные)
	ДеревоПолейОбъекта = AINSYS_сервер.ВыгрузитьТаблицуЗначенийВДеревоЗначений(спрОписаниеДанных.ПоляОбъектаДанных.Выгрузить(), "КлючСтроки", "КлючРодителя");
	
	масРез = Новый Массив;
	
	Если ТипЗнч(ПолученныеДанные) = Тип("Структура") Тогда
		рез = ПолучитьЗагружаемуюСтруктуру(ДеревоПолейОбъекта, ПолученныеДанные);
		масРез.Добавить(рез);
	ИначеЕсли ТипЗнч(ПолученныеДанные) = Тип("Массив") И ПолученныеДанные.Количество() > 0 Тогда
		Для Каждого ПолученныйЭлемент из ПолученныеДанные Цикл
			рез = ПолучитьЗагружаемуюСтруктуру(ДеревоПолейОбъекта, ПолученныйЭлемент);
			масРез.Добавить(рез);
		КонецЦикла;
	КонецЕсли;
	
	Возврат масРез;
КонецФункции

Функция РазобратьИЗагрузитьВходящийЗапрос(спрПланСинхронизации, стркВходящийЗапрос)

	стркСДанными = Новый Структура("Данные, Действие, Ошибка, Правило");
	Если ТипЗнч(стркВходящийЗапрос) <> Тип("Структура") ИЛИ НЕ стркВходящийЗапрос.Свойство("entity") Тогда
		стркСДанными.Ошибка = "Полученный запрос не содержит ссылки на правило обмена. Отсутствует поле entity";
		Возврат стркСДанными;
	КонецЕсли;

	идПравила = Неопределено;
	имяПравила = Неопределено;
	стркВходящийЗапрос.entity.Свойство("id", идПравила);
	стркВходящийЗапрос.entity.Свойство("name", имяПравила);
	Если ТипЗнч(стркВходящийЗапрос.entity) <> Тип("Структура") ИЛИ (идПравила = Неопределено и имяПравила = Неопределено) Тогда
		стркСДанными.Ошибка = "Полученный запрос не содержит ссылки на правило обмена. Отсутствует поле entity.id";
		Возврат стркСДанными;
	КонецЕсли;

	спрОписаниеДанных = AINSYS_сервер.ПолучитьСсылкуПоИД(идПравила, "AINSYS_ОписаниеДанных");
	Если Не ЗначениеЗаполнено(спрОписаниеДанных) Тогда
		// сторонняя система прислала кривой или собственный идентификатор, поищем по наименованию.
		спрОписаниеДанных = ПолучитьПравилоПоНаименованию(имяПравила, спрПланСинхронизации);
		Если спрОписаниеДанных = Неопределено ИЛИ спрОписаниеДанных.ПланСинхронизации <> спрПланСинхронизации Тогда
			стркСДанными.Ошибка = "Правило id " + идПравила + ", имя " + имяПравила + " не принадлежит плану синхронизации переданным с ключом.";
			Возврат стркСДанными;
		КонецЕсли;
	КонецЕсли;
	стркСДанными.Правило = спрОписаниеДанных;
	
	ПолученныеДанные = Неопределено;
	Если НЕ стркВходящийЗапрос.Свойство("payload", ПолученныеДанные) ИЛИ
			НЕ (ТипЗнч(ПолученныеДанные) = Тип("Массив") ИЛИ ТипЗнч(ПолученныеДанные) = Тип("Структура")) Тогда
		стркСДанными.Ошибка = "Во входящем запросе id: " + идПравила + ", наименование: " + имяПравила + " не найдено данных. Поле payload должно содержать объект или массив";
		Возврат стркСДанными;
	КонецЕсли;
	
	Действие = "";
	стркВходящийЗапрос.Свойство("action", Действие);
	стркСДанными.Действие = Действие;
	
	Если Не ПустаяСтрока(стркСДанными.Ошибка) Тогда
		ЗаписатьОшибкуВЖурнал(спрОписаниеДанных, стркСДанными.Ошибка);
	Иначе
		стркСДанными.Данные = ПривестиДанныеКЗагружаемомуВиду(спрОписаниеДанных, ПолученныеДанные);
		
		// появление новых полей проверяем раз в сутки
		Если ТекущаяДата() - AINSYS_сервер.ЗначениеРеквизитаОбъекта(спрОписаниеДанных, "ДатаСверкиПолей") >= 86400 Тогда
			ОтметитьНовыеПоля(спрОписаниеДанных, ПолученныеДанные, стркВходящийЗапрос);
		КонецЕсли;
	КонецЕсли;	
	
	Если Не ПустаяСтрока(стркСДанными.Ошибка) ИЛИ стркСДанными.Данные = Неопределено Тогда
		стркСДанными.Статус = 400;
		стркСДанными.Результат = стркСДанными.Ошибка;
		Возврат стркСДанными;
	Иначе
		ВыполнитьСкриптЗагрузки(стркСДанными);
	КонецЕсли;
	
	Возврат стркСДанными;
КонецФункции

// Проверяет входящий запрос от внешней системы на допустимость, выбирает из него данные.
// Параметры:
//		спрПланСинхронизации - СправочникСсылка.AINSYS_ПланыСинхронизации - полученные данные должны принмадлежать этому правилу
// 		ТекстВходящегоЗапроса - Строка json - объект с данными, которые нужно записать в 1С. В поле entity.id должен быть идентификатор элмента справочника AINSYS_ОписаниеДанных
// Возвращаемое значение:
//		Структура с полями
//			Данные - что собственно надо записать
//			Действие - удалить/записать/изменить
//			Ошибка - описание ошибки, позникшей при проверке входящих данных
Функция ЗагрузитьВходящийЗапрос(спрПланСинхронизации, ТекстВходящегоЗапроса)
	// пример входящего запроса
	//
	//"entity": {
	//"id": "40c0f117-67d4-11ec-8265-f6fd97ac31f9",
	//"name": "NAME OF ENTITY"
	//},
	//"action": "ADD"
	// "payload": {
	//"Ссылка": {"id": "40c0f117-67d4-11ec-8265-f6fd97ac31f9", "Представление": "Заказ клиента КП00-020067 от 28.12.2021 14:49:47"},
	//"Комментарий": "некий комментарий " + Строка(ТекущаяДата()) + "",
	//"Сумма": 1667.69,
	//"Номер": "ЕТ00-001124",
	//"Дата": "2021-12-29T16:15:15"
	//}
	//}
	
	// вариант входящего запроса с массивом
	//[
	//	{
	//		"entity": {
	//			"id": 123,
	//			"name": "NAME OF ENTITY"
	//		},
	//		"action": "CREATE" // CREATE, UPDATE, DELETE
	//		"payload": {
	//			// Поля с данными сущности
	//			"Количество": 1,
	//			"Сумма": 1667.69,
	//			"Номер": "ЕТ00-001124",
	//			"Дата": "2021-12-29T16:15:15"
	//		}
	//	},
	//	{
	//		"entity": {
	//			"id": 123,
	//			"name": "NAME OF ENTITY"
	//		},
	//		"action": "CREATE" // CREATE, UPDATE, DELETE
	//		"payload": {
	//			// Поля с данными сущности
	//			"Количество": 1,
	//			"Сумма": 1667.69,
	//			"Номер": "ЕТ00-001124",
	//			"Дата": "2021-12-29T16:15:15"
	//		}
	//	}
	//]	
	
	стркСДанными = Новый Структура("Данные, Действие, Ошибка, Правило");
	
	ВходящийЗапрос = AINSYS_сервер.ЗначениеИзJson(ТекстВходящегоЗапроса);
	Если ТипЗнч(ВходящийЗапрос) = Тип("Массив") Тогда
		Для Каждого стркВходящийЗапрос из ВходящийЗапрос Цикл
			стркСДанными = РазобратьИЗагрузитьВходящийЗапрос(спрПланСинхронизации, стркВходящийЗапрос);
			Если НЕ ПустаяСтрока(стркСДанными.Ошибка) Тогда
				Прервать
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(ВходящийЗапрос) = Тип("Структура") Тогда
		стркСДанными = РазобратьИЗагрузитьВходящийЗапрос(спрПланСинхронизации, ВходящийЗапрос);
	Иначе
		стркСДанными.Ошибка = "Получены данные в неподдерживаемом формате: " + ТекстВходящегоЗапроса;
	КонецЕсли;
	
	Возврат стркСДанными;
КонецФункции

// Параметр 
//		стркСДанными - Структура - содержит поля:
//							Данные - Массив - с объектами для загрузки
//							Действие
//							Ошибка - Строка - сюда пишем ошибки, если такие возникнут
//							Правило - СправочникСсылка.AINSYS_ОписаниеДанных - ссылка на текущее правило обмена
Процедура ВыполнитьСкриптЗагрузки(стркСДанными)
	текстОбработкиЗагрузки = AINSYS_сервер.ЗначениеРеквизитаОбъекта(стркСДанными.Правило, "ОбработкаЗагрузки");
	Попытка
		Выполнить(текстОбработкиЗагрузки);
	Исключение
		стркСДанными.Ошибка = ОписаниеОшибки();
	КонецПопытки;
КонецПроцедуры

// Параметры:
// спрПланСинхронизации - СправочникСсылка.AINSYS_ПланыСинхронизации -
// ТекстВходящегоЗапроса - Строка - json текстом
//
// Возвращаемое значение - Структура - с полями Статус и Результат.
//		В поле статус пишется код http
Функция ЗаписатьДанные(спрПланСинхронизации, ТекстВходящегоЗапроса) Экспорт
	стркрезультат = Новый Структура("Статус, Результат", 200);
	
	стркСДанными = ЗагрузитьВходящийЗапрос(спрПланСинхронизации, ТекстВходящегоЗапроса);

	Если ПустаяСтрока(стркСДанными.Ошибка) Тогда
		стркРезультат.Статус = 200;
		стркРезультат.Результат = "Всё хорошо :-)";
	Иначе
		стркРезультат.Статус = 501;
		стркРезультат.Результат = стркСДанными.Ошибка;
		
		ЗаписатьОшибкуВЖурнал(стркСДанными.Правило, стркСДанными.Ошибка);
	КонецЕсли;
	
	Возврат стркРезультат;
	
КонецФункции

#КонецОбласти

#Область ОтправкаДанных

Функция ПолучитьотправляемуюСтруктуру(ссылкаНаПравило)
	стркРезультат = Новый Структура("entity, action, payload",
										Новый Структура("id, name", xmlСтрока(ссылкаНаПравило), Строка(ссылкаНаПравило)),
										"update");
	Возврат стркРезультат;
КонецФункции

Функция ОтправитьДанныеКорУзлу(ЭтоПравило, Количество = 0, Смещение = 0, Измененные = Ложь, ВходящийЗапрос = "") Экспорт
	РезультатОтправки = Новый Структура("Ошибка, ОтветСервера");
	Если ПустаяСтрока(ЭтоПравило.ОбработкаОтправкиДанныхКорУзлу) Тогда
		РезультатОтправки = ОтправитьДанные(ЭтоПравило, Количество, Смещение, Измененные, ВходящийЗапрос);
	ИначеЕсли стрНайти(ЭтоПравило.ОбработкаОтправкиДанныхКорУзлу, "ОтправитьДанныеКорУзлу") > 0 Тогда
		РезультатОтправки.Ошибка = "Функцию ОтправитьДанныеКорУзлу использовать нельзя. Вместо неё используйте ОтправитьДанные";
		Сообщить(РезультатОтправки.Ошибка);
	Иначе
		Выполнить(ЭтоПравило.ОбработкаОтправкиДанныхКорУзлу);
	КонецЕсли;
	
	Возврат РезультатОтправки;
КонецФункции

Функция ОтправитьДанные(ссылкаНаПравило, Количество = 0, Смещение = 0, Измененные = Ложь, ВходящийЗапрос = "")
	стркРезультат = Новый Структура("Ошибка, ОтветСервера", "");
	стркОтправляемыеДанные = ПолучитьВыгружаемыеДанные(ссылкаНаПравило, "json", Количество, Смещение, Измененные, ВходящийЗапрос);
	
	ОтправляемоеЗначение = Новый Массив;
	Если ТипЗнч(стркОтправляемыеДанные.Данные) = Тип("Массив") И стркОтправляемыеДанные.Данные.Количество() > 0 Тогда
		Для Каждого ОбъектДанных Из стркОтправляемыеДанные.Данные Цикл
			стркОтправяляемая = ПолучитьотправляемуюСтруктуру(ссылкаНаПравило);
			стркОтправяляемая.payload = ОбъектДанных;
			ОтправляемоеЗначение.Добавить(стркОтправяляемая);
		КонецЦикла;
	Иначе
		стркОтправяляемая = ПолучитьотправляемуюСтруктуру(ссылкаНаПравило);
		стркОтправяляемая.payload = стркОтправляемыеДанные.Данные;
		ОтправляемоеЗначение.Добавить(стркОтправяляемая);
	КонецЕсли;
	
	АдресКорУзла = AINSYS_сервер.ЗначениеРеквизитаОбъекта(ссылкаНаПравило.ПланСинхронизации, "АдресКорУзла");
	Если ПустаяСтрока(АдресКорУзла) Тогда
		стркРезультат.Ошибка = "В плане синхронизации правила " + Строка(ссылкаНаПравило) + " не указан адрес корреспондирующего узла.";
		Возврат стркРезультат;
	КонецЕсли;
	
	ДополнительныеДанные = Новый Структура("json", ОтправляемоеЗначение);
	стр = AINSYS_сервер.ЗначениеВjson(ДополнительныеДанные); // ссылки сериализуются. Преобразуются в json.
	ДополнительныеДанные = AINSYS_сервер.ЗначениеИзJson(стр);
	
	стркРезультат.ОтветСервера = AINSYS_HTTP.ВызватьМетод("POST", АдресКорУзла, ДополнительныеДанные);
	
	Если ТипЗнч(стркОтправляемыеДанные.СписокИзмененных) = Тип("СписокЗначений") И стркРезультат.ОтветСервера.Ответ.КодСостояния = 200 Тогда
		СнятьФлагИзмененности(ссылкаНаПравило, стркОтправляемыеДанные.СписокИзмененных);
	КонецЕсли;
	
	Возврат стркРезультат;

КонецФункции

#КонецОбласти
